### Eclipse Workspace Patch 1.0
#P org.eclipse.imp.smapi
Index: META-INF/MANIFEST.MF
===================================================================
--- META-INF/MANIFEST.MF	(revision 21620)
+++ META-INF/MANIFEST.MF	(working copy)
@@ -5,6 +5,7 @@
 Bundle-Version: 0.1.88
 Bundle-Localization: plugin
 Eclipse-LazyStart: true
+Bundle-ActivationPolicy: lazy
 Export-Package: org.eclipse.imp.smapi
 Require-Bundle: org.junit,
  com.ibm.wala.shrike
Index: build.properties
===================================================================
--- build.properties	(revision 21620)
+++ build.properties	(working copy)
@@ -1,10 +1,11 @@
 bin.includes = META-INF/,\
                bin/,\
-			   .
+               .,\
+               plugin.properties
 src.includes = .cvsignore,\
                .classpath,\
                .project,\
                META-INF/,\
                build.properties,\
                src/
-source.. = src/
\ No newline at end of file
+source.. = src/
Index: .classpath
===================================================================
--- .classpath	(revision 21620)
+++ .classpath	(working copy)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: .settings/org.eclipse.jdt.core.prefs
===================================================================
--- .settings/org.eclipse.jdt.core.prefs	(revision 21620)
+++ .settings/org.eclipse.jdt.core.prefs	(working copy)
@@ -1,4 +1,4 @@
-#Tue Nov 13 14:07:22 EST 2007
+#Thu Aug 21 16:49:25 BST 2008
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
@@ -7,6 +7,65 @@
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=ignore
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=ignore
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5
Index: plugin.properties
===================================================================
#P org.eclipse.imp.runtime
Index: plugin.properties
===================================================================
Index: plugin.xml
===================================================================
--- plugin.xml	(revision 21620)
+++ plugin.xml	(working copy)
@@ -63,6 +63,10 @@
             markerSeverity="1"
             name="org.eclipse.imp.editor.parseAnnotation"
             super="org.eclipse.ui.workbench.texteditor.error"/>
+      <type
+            markerSeverity="1"
+            name="org.eclipse.imp.runtime.occurrenceAnnotation"
+            super="org.eclipse.ui.workbench.texteditor.error"/>
    </extension>
    <extension
          point="org.eclipse.ui.editors.markerAnnotationSpecification">
Index: .classpath
===================================================================
--- .classpath	(revision 20869)
+++ .classpath	(working copy)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: META-INF/MANIFEST.MF
===================================================================
--- META-INF/MANIFEST.MF	(revision 21620)
+++ META-INF/MANIFEST.MF	(working copy)
@@ -33,6 +33,7 @@
  com.ibm.icu,
  org.eclipse.help
 Eclipse-LazyStart: true
+Bundle-ActivationPolicy: lazy
 Export-Package: org.eclipse.imp.builder,
  org.eclipse.imp.core,
  org.eclipse.imp.editor,
Index: build.properties
===================================================================
--- build.properties	(revision 20869)
+++ build.properties	(working copy)
@@ -3,5 +3,6 @@
 bin.includes = META-INF/,\
                .,\
                plugin.xml,\
-               icons/
+               icons/,\
+               plugin.properties
 src.includes = icons/
Index: src/org/eclipse/imp/language/LanguageRegistry.java
===================================================================
--- src/org/eclipse/imp/language/LanguageRegistry.java	(revision 21620)
+++ src/org/eclipse/imp/language/LanguageRegistry.java	(working copy)
@@ -22,6 +22,7 @@
 import java.util.Map;
 
 import org.eclipse.core.runtime.IConfigurationElement;
+import org.eclipse.core.runtime.IExtension;
 import org.eclipse.core.runtime.IExtensionPoint;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.InvalidRegistryObjectException;
@@ -39,6 +40,7 @@
 import org.eclipse.swt.widgets.Display;
 import org.eclipse.ui.IEditorDescriptor;
 import org.eclipse.ui.IEditorInput;
+import org.eclipse.ui.IEditorMatchingStrategy;
 import org.eclipse.ui.IFileEditorMapping;
 import org.eclipse.ui.PlatformUI;
 import org.eclipse.ui.internal.registry.EditorDescriptor;
@@ -404,6 +406,24 @@
 	        	    	break;
 	        	    }
 	        	}
+	        	if (!gotIt) {
+	        		for (IEditorDescriptor editor : mapping.getEditors()) {	// Search for an implicit copy of a derived UniversalEditor
+		        		EditorDescriptor editorDescriptor = (EditorDescriptor) editor;
+						String className = editorDescriptor.getClassName();
+						IConfigurationElement configurationElement = editorDescriptor.getConfigurationElement();
+						IExtension declaringExtension = configurationElement.getDeclaringExtension();
+						String namespaceIdentifier = declaringExtension.getNamespaceIdentifier();
+						Bundle bundle = Platform.getBundle(namespaceIdentifier);
+		        		try {
+							Class<?> editorClass = bundle.loadClass(className);
+			        		if (UniversalEditor.class.isAssignableFrom(editorClass)) {
+			        			gotIt = true;
+			        			break;
+			        		}
+						} catch (ClassNotFoundException e) {
+						}
+		        	}
+	        	}
 	        	if (!gotIt)
 	        		((FileEditorMapping) mapping).addEditor((EditorDescriptor) sUniversalEditor);
 	        }
Index: src/org/eclipse/imp/wizards/NewProjectWizardSecondPage.java
===================================================================
--- src/org/eclipse/imp/wizards/NewProjectWizardSecondPage.java	(revision 21620)
+++ src/org/eclipse/imp/wizards/NewProjectWizardSecondPage.java	(working copy)
@@ -54,7 +54,6 @@
 import org.eclipse.jdt.core.IClasspathEntry;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.JavaCore;
-import org.eclipse.jdt.internal.corext.util.JavaModelUtil;
 import org.eclipse.jdt.internal.corext.util.Messages;
 import org.eclipse.jdt.internal.ui.dialogs.StatusInfo;
 import org.eclipse.jdt.internal.ui.util.CoreUtility;
@@ -150,14 +149,14 @@
             if (compliance != null) {
                 IJavaProject project= JavaCore.create(fCurrProject);
                 Map<?, ?> options= project.getOptions(false);
-                JavaModelUtil.setCompilanceOptions(options, compliance);
+                JavaCore.setComplianceOptions(compliance, options);
                 project.setOptions(options);
             }
         } finally {
             monitor.done();
             fCurrProject= null;
             if (fIsAutobuild != null) {
-                CoreUtility.enableAutoBuild(fIsAutobuild.booleanValue());
+                CoreUtility.setAutoBuilding(fIsAutobuild.booleanValue());
                 fIsAutobuild= null;
             }
         }
@@ -193,7 +192,7 @@
             public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {
                 try {
                     if (fIsAutobuild == null) {
-                        fIsAutobuild= Boolean.valueOf(CoreUtility.enableAutoBuild(false));
+                        fIsAutobuild= Boolean.valueOf(CoreUtility.setAutoBuilding(false));
                     }
                     infoStatus= updateProject(monitor);
                 } catch (CoreException e) {
@@ -527,7 +526,7 @@
 
                 restoreExistingFiles(projLoc, new SubProgressMonitor(monitor, 1));
             } finally {
-                CoreUtility.enableAutoBuild(fIsAutobuild.booleanValue()); // fIsAutobuild must be set
+                CoreUtility.setAutoBuilding(fIsAutobuild.booleanValue()); // fIsAutobuild must be set
                 fIsAutobuild= null;
             }
         } catch (CoreException e) {
Index: src/org/eclipse/imp/utils/HTMLPrinter.java
===================================================================
--- src/org/eclipse/imp/utils/HTMLPrinter.java	(revision 20869)
+++ src/org/eclipse/imp/utils/HTMLPrinter.java	(working copy)
@@ -212,19 +212,7 @@
      * Formats several messages as HTML text.
      */
     public static String formatMultipleMessages(List/*<String>*/ messages) {
-        if (true) { // until we hook in the HTML-enabled hover viewer
-            StringBuffer buff= new StringBuffer();
-            buff.append("Multiple messages:\n");
-            for(Iterator iter= messages.iterator(); iter.hasNext();) {
-        	String msg= (String) iter.next();
-        	buff.append("  ");
-        	buff.append(msg);
-        	if (iter.hasNext())
-        	    buff.append('\n');
-            }
-            return buff.toString();
-        }
-        StringBuffer buffer= new StringBuffer();
+    	StringBuffer buffer= new StringBuffer();
         addPageProlog(buffer);
         addParagraph(buffer, convertToHTMLContent("There are multiple markers on this line."));
         startBulletList(buffer);
@@ -240,8 +228,6 @@
      * Formats a message as HTML text.
      */
     public static String formatSingleMessage(String message) {
-        if (true) // until we hook in the HTML-enabled hover viewer
-            return message;
         StringBuffer buffer= new StringBuffer();
         addPageProlog(buffer);
         addParagraph(buffer, convertToHTMLContent(message));
Index: src/org/eclipse/imp/editor/AnnotationHoverBase.java
===================================================================
--- src/org/eclipse/imp/editor/AnnotationHoverBase.java	(revision 21620)
+++ src/org/eclipse/imp/editor/AnnotationHoverBase.java	(working copy)
@@ -159,8 +159,6 @@
      * Formats a message as HTML text.
      */
     public static String formatSingleMessage(String message) {
-        if (true) // until we hook in the HTML-enabled hover viewer
-            return message;
         StringBuffer buffer= new StringBuffer();
         HTMLPrinter.addPageProlog(buffer);
         HTMLPrinter.addParagraph(buffer, HTMLPrinter.convertToHTMLContent(message));
@@ -173,18 +171,6 @@
      */
     public static String formatMultipleMessages(List<String> messages) {
         // TODO Hook in the HTML-enabled hover viewer
-        if (true) { // until we hook in the HTML-enabled hover viewer
-            StringBuilder sb= new StringBuilder();
-
-            sb.append("Multiple messages:\n");
-            int idx= 0;
-            for(String msg: messages) {
-                if (idx++ > 0) { sb.append('\n'); }
-                sb.append("  ");
-                sb.append(msg);
-            }
-            return sb.toString();
-        }
         StringBuffer buffer= new StringBuffer();
         HTMLPrinter.addPageProlog(buffer);
         HTMLPrinter.addParagraph(buffer, HTMLPrinter.convertToHTMLContent("Multiple messages at this line"));
Index: src/org/eclipse/imp/editor/internal/PresentationController.java
===================================================================
--- src/org/eclipse/imp/editor/internal/PresentationController.java	(revision 21620)
+++ src/org/eclipse/imp/editor/internal/PresentationController.java	(working copy)
@@ -13,6 +13,8 @@
 
 import java.io.PrintStream;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Stack;
@@ -184,17 +186,27 @@
         }
     }
 
-    private void submitTextPresentation(final TextPresentation presentation) {
-
+    private void submitTextPresentation(final TextPresentation uncheckedPresentation) {
+    	int charCount = 0;
+    	if (fSourceViewer != null) {		
+    		IDocument document = fSourceViewer.getDocument();
+			if (document != null)			// EDW 27 Sep 2008 May be null after file deleted
+				charCount = document.getLength();
+    	}
+    	final TextPresentation presentation;
+    	if (!checkPresentation(uncheckedPresentation, charCount))
+			presentation = correctPresentation(uncheckedPresentation, charCount);
+    	else
+    		presentation = uncheckedPresentation;
         Display.getDefault().asyncExec(new Runnable() {
             public void run() {
             	
             	// SMS 16 Sep 2008
-            	int charCount;
-            	if (fSourceViewer != null) {
-            		charCount = fSourceViewer.getDocument().getLength();
-            	} else {
-            		charCount = 0;
+            	int charCount = 0;
+            	if (fSourceViewer != null) {		
+            		IDocument document = fSourceViewer.getDocument();
+					if (document != null)			// EDW 27 Sep 2008 May be null after file deleted
+						charCount = document.getLength();
             	}
             	
             	// Attempt to head off exception due to final range extending beyond
@@ -272,4 +284,78 @@
             }
         });
     }
+
+	private boolean checkPresentation(TextPresentation presentation, int charCount) {		// EDW
+		Iterator presIt = presentation.getAllStyleRangeIterator();
+		int end = -1;
+		while (presIt.hasNext()) {
+			StyleRange nextRange = (StyleRange) presIt.next();
+        	int start = nextRange.start;
+           	int length = nextRange.length;
+            if (start < end) {
+        		System.out.println("Unexpected style start " + start + ":" + length + ":" + (start + length) + "/" + charCount);
+        		return false;
+        	}
+        	if (length < 1) {
+        		System.out.println("Unexpected style length " + start + ":" + length + ":" + (start + length) + "/" + charCount);
+        		return false;
+        	}
+        	end = start + length;      	
+        	if (end > charCount) {
+        		System.out.println("Unexpected style end " + start + ":" + length + ":" + (start + length) + "/" + charCount);
+        		return false;
+        	}
+		}
+		return true;
+	}
+
+	private TextPresentation correctPresentation(TextPresentation presentation, int charCount) {		// EDW
+		List<StyleRange> ranges = new ArrayList<StyleRange>();
+		Iterator presIt = presentation.getAllStyleRangeIterator();
+		for (int styleNumber = 0; presIt.hasNext(); styleNumber++) {
+			StyleRange range = (StyleRange) presIt.next();
+        	int start = range.start;
+        	int length = range.length;
+    		if (length <= 0)
+        		System.out.println("Ignored -ve length style " + styleNumber + ": " + range.start + ":" + range.length + ":" + (range.start + range.length) + "/" + charCount);
+    		else if (start >= charCount)
+        		System.out.println("Ignored past-end style " + styleNumber + ": " + range.start + ":" + range.length + ":" + (range.start + range.length) + "/" + charCount);
+    		else {
+        		int end = start + length;
+        		if (end > charCount) {
+            		System.out.println("Truncated over-end style " + styleNumber + ": " + range.start + ":" + range.length + ":" + (range.start + range.length) + "/" + charCount);
+            		range.length = charCount - start;
+        		}
+        		ranges.add(range);
+        	}
+		}
+		Collections.sort(ranges, new Comparator<StyleRange>()
+		{
+			public int compare(StyleRange o1, StyleRange o2) {
+				return o1.start - o2.start;
+			}
+		});
+		IDocument document = fSourceViewer.getDocument();
+		TextPresentation newPresentation = new TextPresentation();
+		int iMax = ranges.size();
+		for (int i = 0; i < iMax; i++) {
+			StyleRange thisRange = ranges.get(i);
+			if ((i+1) < iMax) {
+				StyleRange nextRange = ranges.get(i+1);
+        		int end = thisRange.start + thisRange.length;
+				if (end > nextRange.start) {
+            		try {
+						System.out.println("Truncated over-lap style " + i + " " +
+								thisRange.start + ":" + thisRange.length + ":" + (thisRange.start + thisRange.length) + ":'" + document.get(thisRange.start, thisRange.length) + "' " +
+								nextRange.start + ":" + nextRange.length + ":" + (nextRange.start + nextRange.length) + ":'" + document.get(nextRange.start, nextRange.length) + "'");
+					} catch (BadLocationException e) {
+						e.printStackTrace();
+					}
+					thisRange.length = nextRange.start - thisRange.start;
+				}
+			}
+			newPresentation.addStyleRange(thisRange);
+		}
+		return newPresentation;
+	}
 }
Index: src/org/eclipse/imp/editor/ParserScheduler.java
===================================================================
--- src/org/eclipse/imp/editor/ParserScheduler.java	(revision 21620)
+++ src/org/eclipse/imp/editor/ParserScheduler.java	(working copy)
@@ -47,8 +47,6 @@
 
     private final List<IModelListener> fAstListeners= new ArrayList<IModelListener>();
 
-//  private final IPreferencesService fPrefService;
-
     public ParserScheduler(IParseController parseController, IEditorPart editorPart,
             IDocumentProvider docProvider, IMessageHandler msgHandler) {
     	super(LanguageRegistry.findLanguage(EditorInputUtils.getPath(editorPart.getEditorInput()), null).getName() + " ParserScheduler for " + editorPart.getEditorInput().getName());
@@ -57,7 +55,6 @@
         fEditorPart= editorPart;
         fDocumentProvider= docProvider;
         fMsgHandler= msgHandler;
-//      fPrefService= new PreferencesService(fParseController.getProject().getRawProject(), fParseController.getLanguage().getName());
 
         // rmf 7/1/2008 - N.B. The parse controller is now initialized before it gets handed to us here,
         // since some other services may actually depend on that.
@@ -71,12 +68,14 @@
 
         IEditorInput editorInput= fEditorPart.getEditorInput();
         try {
-            IDocument document= fDocumentProvider.getDocument(editorInput);
-
-            if (PreferenceCache.emitMessages /* fPrefService.getBooleanPreference(PreferenceConstants.P_EMIT_MESSAGES) */) {
+            IDocument document = fDocumentProvider.getDocument(editorInput);
+            if (document == null) {				// EDW 29 Sep 2008
+                /* Editor was deleted */
+                return Status.OK_STATUS;
+            }
+            if (PreferenceCache.emitMessages)
                 RuntimePlugin.getInstance().writeInfoMsg(
                         "Parsing language " + fParseController.getLanguage().getName() + " for input " + editorInput.getName());
-            }
 
             // Don't need to retrieve the AST; we don't need it.
             // Just make sure the document contents gets parsed once (and only once).
@@ -104,16 +103,9 @@
     public void notifyModelListeners(IProgressMonitor monitor) {
         // Suppress the notification if there's no AST (e.g. due to a parse error)
         if (fParseController != null) {
-            if (
-                PreferenceCache.emitMessages
-                // TODO RMF Switch to pref svc for this, once the "global" IMP preferences (using the "IMP" pseudo-language name) gets initialized properly
-//              fPrefService.isDefined(PreferenceConstants.P_EMIT_MESSAGES) &&
-//              fPrefService.getBooleanPreference(PreferenceConstants.P_EMIT_MESSAGES) ||
-//              RuntimePlugin.getInstance().getPreferencesService().getBooleanPreference(PreferenceConstants.P_EMIT_MESSAGES)
-                ) {
+            if (PreferenceCache.emitMessages)
                 RuntimePlugin.getInstance().writeInfoMsg(
                         "Notifying AST listeners of change in " + fParseController.getPath().toPortableString());
-            }
             for(int n= fAstListeners.size() - 1; n >= 0 && !monitor.isCanceled(); n--) {
                 IModelListener listener= fAstListeners.get(n);
                 // Pretend to get through the highest level of analysis so all services execute (for now)
@@ -134,12 +126,7 @@
 //            long diffToEditorStart= curTime - RuntimePlugin.EDITOR_START_TIME;
 //            System.out.println("Time from runtime start: " + diffToRuntimeStart);
 //            System.out.println("Time from editor start: " + diffToEditorStart);
-        } else if (PreferenceCache.emitMessages
-//                fPrefService.isDefined(PreferenceConstants.P_EMIT_MESSAGES) &&
-//                fPrefService.getBooleanPreference(PreferenceConstants.P_EMIT_MESSAGES) ||
-//                RuntimePlugin.getInstance().getPreferencesService().getBooleanPreference(PreferenceConstants.P_EMIT_MESSAGES)
-                ) {
+        } else if (PreferenceCache.emitMessages)
             RuntimePlugin.getInstance().writeInfoMsg("No AST; bypassing listener notification.");
-        }
     }
 }
Index: src/org/eclipse/imp/preferences/fields/details/DetailsDialogForComboFields.java
===================================================================
--- src/org/eclipse/imp/preferences/fields/details/DetailsDialogForComboFields.java	(revision 21620)
+++ src/org/eclipse/imp/preferences/fields/details/DetailsDialogForComboFields.java	(working copy)
@@ -32,10 +32,8 @@
 import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Shell;
-import org.eclipse.ui.internal.dialogs.ProductInfoDialog;
 
-
-public class DetailsDialogForComboFields extends ProductInfoDialog {
+public class DetailsDialogForComboFields extends AbstractDetailsDialog {
 
 	Shell parent = null;
 	ComboFieldEditor field = null;
Index: src/org/eclipse/imp/preferences/fields/details/DetailsDialogForFontFields.java
===================================================================
--- src/org/eclipse/imp/preferences/fields/details/DetailsDialogForFontFields.java	(revision 21620)
+++ src/org/eclipse/imp/preferences/fields/details/DetailsDialogForFontFields.java	(working copy)
@@ -33,10 +33,8 @@
 import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Shell;
-import org.eclipse.ui.internal.dialogs.ProductInfoDialog;
 
-
-public class DetailsDialogForFontFields extends ProductInfoDialog {
+public class DetailsDialogForFontFields extends AbstractDetailsDialog {
 
 	Shell parent = null;
 	FontFieldEditor field = null;
Index: src/org/eclipse/imp/preferences/fields/details/AbstractDetailsDialog.java
===================================================================
--- src/org/eclipse/imp/preferences/fields/details/AbstractDetailsDialog.java	(revision 0)
+++ src/org/eclipse/imp/preferences/fields/details/AbstractDetailsDialog.java	(revision 0)
@@ -0,0 +1,470 @@
+package org.eclipse.imp.preferences.fields.details;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.StringTokenizer;
+
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Platform;
+import org.eclipse.jface.dialogs.TrayDialog;
+import org.eclipse.jface.resource.JFaceColors;
+import org.eclipse.osgi.util.NLS;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.StyleRange;
+import org.eclipse.swt.custom.StyledText;
+import org.eclipse.swt.events.KeyAdapter;
+import org.eclipse.swt.events.KeyEvent;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseMoveListener;
+import org.eclipse.swt.events.TraverseEvent;
+import org.eclipse.swt.events.TraverseListener;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Cursor;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.ui.PartInitException;
+import org.eclipse.ui.PlatformUI;
+import org.eclipse.ui.browser.IWebBrowser;
+import org.eclipse.ui.browser.IWorkbenchBrowserSupport;
+import org.eclipse.ui.internal.WorkbenchMessages;
+import org.eclipse.ui.internal.WorkbenchPlugin;
+import org.eclipse.ui.internal.about.AboutItem;
+import org.eclipse.ui.internal.misc.StatusUtil;
+import org.eclipse.ui.statushandlers.StatusManager;
+
+/**
+ * Abstract superclass of about dialogs 
+ * 
+ * This code was originally org.eclipse.ui.internal.dialogs.ProductInfoDialog
+ */
+
+public abstract class AbstractDetailsDialog extends TrayDialog {
+
+    private AboutItem item;
+
+    private Cursor handCursor;
+
+    private Cursor busyCursor;
+
+    private boolean mouseDown = false;
+
+    private boolean dragEvent = false;
+
+    /**
+     * Create an instance of this Dialog
+     */
+    public AbstractDetailsDialog(Shell parentShell) {
+        super(parentShell);
+    }
+
+    /**
+     * Adds listeners to the given styled text
+     */
+    protected void addListeners(StyledText styledText) {
+        styledText.addMouseListener(new MouseAdapter() {
+            public void mouseDown(MouseEvent e) {
+                if (e.button != 1) {
+                    return;
+                }
+                mouseDown = true;
+            }
+
+            public void mouseUp(MouseEvent e) {
+                mouseDown = false;
+                StyledText text = (StyledText) e.widget;
+                int offset = text.getCaretOffset();
+                if (dragEvent) {
+                    // don't activate a link during a drag/mouse up operation
+                    dragEvent = false;
+                    if (item != null && item.isLinkAt(offset)) {
+                        text.setCursor(handCursor);
+                    }
+                } else if (item != null && item.isLinkAt(offset)) {
+                    text.setCursor(busyCursor);
+                    openLink(item.getLinkAt(offset));
+                    StyleRange selectionRange = getCurrentRange(text);
+                    text.setSelectionRange(selectionRange.start,
+                            selectionRange.length);
+                    text.setCursor(null);
+                }
+            }
+        });
+
+        styledText.addMouseMoveListener(new MouseMoveListener() {
+            public void mouseMove(MouseEvent e) {
+                // Do not change cursor on drag events
+                if (mouseDown) {
+                    if (!dragEvent) {
+                        StyledText text = (StyledText) e.widget;
+                        text.setCursor(null);
+                    }
+                    dragEvent = true;
+                    return;
+                }
+                StyledText text = (StyledText) e.widget;
+                int offset = -1;
+                try {
+                    offset = text.getOffsetAtLocation(new Point(e.x, e.y));
+                } catch (IllegalArgumentException ex) {
+                    // leave value as -1
+                }
+                if (offset == -1) {
+					text.setCursor(null);
+				} else if (item != null && item.isLinkAt(offset)) {
+					text.setCursor(handCursor);
+				} else {
+					text.setCursor(null);
+				}
+            }
+        });
+
+        styledText.addTraverseListener(new TraverseListener() {
+            public void keyTraversed(TraverseEvent e) {
+                StyledText text = (StyledText) e.widget;
+                switch (e.detail) {
+                case SWT.TRAVERSE_ESCAPE:
+                    e.doit = true;
+                    break;
+                case SWT.TRAVERSE_TAB_NEXT:
+                    //Previously traverse out in the backward direction?
+                    Point nextSelection = text.getSelection();
+                    int charCount = text.getCharCount();
+                    if ((nextSelection.x == charCount)
+                            && (nextSelection.y == charCount)) {
+                        text.setSelection(0);
+                    }
+                    StyleRange nextRange = findNextRange(text);
+                    if (nextRange == null) {
+                        // Next time in start at beginning, also used by 
+                        // TRAVERSE_TAB_PREVIOUS to indicate we traversed out
+                        // in the forward direction
+                        text.setSelection(0);
+                        e.doit = true;
+                    } else {
+                        text.setSelectionRange(nextRange.start,
+                                nextRange.length);
+                        e.doit = true;
+                        e.detail = SWT.TRAVERSE_NONE;
+                    }
+                    break;
+                case SWT.TRAVERSE_TAB_PREVIOUS:
+                    //Previously traverse out in the forward direction?
+                    Point previousSelection = text.getSelection();
+                    if ((previousSelection.x == 0)
+                            && (previousSelection.y == 0)) {
+						text.setSelection(text.getCharCount());
+					}
+                    StyleRange previousRange = findPreviousRange(text);
+                    if (previousRange == null) {
+                        // Next time in start at the end, also used by 
+                        // TRAVERSE_TAB_NEXT to indicate we traversed out
+                        // in the backward direction
+                        text.setSelection(text.getCharCount());
+                        e.doit = true;
+                    } else {
+                        text.setSelectionRange(previousRange.start,
+                                previousRange.length);
+                        e.doit = true;
+                        e.detail = SWT.TRAVERSE_NONE;
+                    }
+                    break;
+                default:
+                    break;
+                }
+            }
+        });
+
+        //Listen for Tab and Space to allow keyboard navigation
+        styledText.addKeyListener(new KeyAdapter() {
+            public void keyPressed(KeyEvent event) {
+                StyledText text = (StyledText) event.widget;
+                if (event.character == ' ' || event.character == SWT.CR) {
+                    if (item != null) {
+                        //Be sure we are in the selection
+                        int offset = text.getSelection().x + 1;
+
+                        if (item.isLinkAt(offset)) {
+                            text.setCursor(busyCursor);
+                            openLink(item.getLinkAt(offset));
+                            StyleRange selectionRange = getCurrentRange(text);
+                            text.setSelectionRange(selectionRange.start,
+                                    selectionRange.length);
+                            text.setCursor(null);
+                        }
+                    }
+                    return;
+                }
+            }
+        });
+    }
+
+    /**
+     * Gets the busy cursor.
+     * @return the busy cursor
+     */
+    protected Cursor getBusyCursor() {
+        return busyCursor;
+    }
+
+    /**
+     * Sets the busy cursor.
+     * @param busyCursor the busy cursor
+     */
+    protected void setBusyCursor(Cursor busyCursor) {
+        this.busyCursor = busyCursor;
+    }
+
+    /**
+     * Gets the hand cursor.
+     * @return Returns a hand cursor
+     */
+    protected Cursor getHandCursor() {
+        return handCursor;
+    }
+
+    /**
+     * Sets the hand cursor.
+     * @param handCursor The hand cursor to set
+     */
+    protected void setHandCursor(Cursor handCursor) {
+        this.handCursor = handCursor;
+    }
+
+    /**
+     * Gets the about item.
+     * @return the about item
+     */
+    protected AboutItem getItem() {
+        return item;
+    }
+
+    /**
+     * Sets the about item.
+     * @param item about item
+     */
+    protected void setItem(AboutItem item) {
+        this.item = item;
+    }
+
+    /**
+     * Find the range of the current selection.
+     */
+    protected StyleRange getCurrentRange(StyledText text) {
+        StyleRange[] ranges = text.getStyleRanges();
+        int currentSelectionEnd = text.getSelection().y;
+        int currentSelectionStart = text.getSelection().x;
+
+        for (int i = 0; i < ranges.length; i++) {
+            if ((currentSelectionStart >= ranges[i].start)
+                    && (currentSelectionEnd <= (ranges[i].start + ranges[i].length))) {
+                return ranges[i];
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Find the next range after the current 
+     * selection.
+     */
+    protected StyleRange findNextRange(StyledText text) {
+        StyleRange[] ranges = text.getStyleRanges();
+        int currentSelectionEnd = text.getSelection().y;
+
+        for (int i = 0; i < ranges.length; i++) {
+            if (ranges[i].start >= currentSelectionEnd) {
+				return ranges[i];
+			}
+        }
+        return null;
+    }
+
+    /**
+     * Find the previous range before the current selection.
+     */
+    protected StyleRange findPreviousRange(StyledText text) {
+        StyleRange[] ranges = text.getStyleRanges();
+        int currentSelectionStart = text.getSelection().x;
+
+        for (int i = ranges.length - 1; i > -1; i--) {
+            if ((ranges[i].start + ranges[i].length - 1) < currentSelectionStart) {
+				return ranges[i];
+			}
+        }
+        return null;
+    }
+
+    /**
+     * display an error message
+     */
+    private void openWebBrowserError(final String href, final Throwable t) {
+        String title = WorkbenchMessages.ProductInfoDialog_errorTitle;
+		String msg = NLS.bind(
+				WorkbenchMessages.ProductInfoDialog_unableToOpenWebBrowser,
+				href);
+		IStatus status = WorkbenchPlugin.getStatus(t);
+		StatusUtil.handleStatus(status, title + ": " + msg, StatusManager.SHOW, //$NON-NLS-1$
+				getShell());
+    }
+
+    /**
+     * Open a link
+     */
+    protected void openLink(String href) {
+        // format the href for an html file (file:///<filename.html>
+        // required for Mac only.
+        if (href.startsWith("file:")) { //$NON-NLS-1$
+            href = href.substring(5);
+            while (href.startsWith("/")) { //$NON-NLS-1$
+                href = href.substring(1);
+            }
+            href = "file:///" + href; //$NON-NLS-1$
+        }
+		IWorkbenchBrowserSupport support = PlatformUI.getWorkbench().getBrowserSupport();
+		try {
+			IWebBrowser browser = support.getExternalBrowser();
+			browser.openURL(new URL(urlEncodeForSpaces(href.toCharArray())));
+		}
+		catch (MalformedURLException e) {
+			openWebBrowserError(href, e);
+		}
+		catch (PartInitException e) {
+			openWebBrowserError(href, e);
+		}
+    }
+
+    /**
+     * This method encodes the url, removes the spaces from the url and replaces
+     * the same with <code>"%20"</code>. This method is required to fix Bug
+     * 77840.
+     * 
+     * @since 3.0.2
+     */
+    private String urlEncodeForSpaces(char[] input) {
+       StringBuffer retu = new StringBuffer(input.length);
+       for (int i = 0; i < input.length; i++) {
+           if (input[i] == ' ') {
+			retu.append("%20"); //$NON-NLS-1$
+		} else {
+			retu.append(input[i]);
+		}
+       }
+       return retu.toString();
+    }
+
+    /**
+     * Open a browser with the argument title on the argument url.  If the url refers to a
+     * resource within a bundle, then a temp copy of the file will be extracted and opened.
+     * @see <code>Platform.asLocalUrl</code>
+     * @param url The target url to be displayed, null will be safely ignored
+     * @return true if the url was successfully displayed and false otherwise
+     */
+    protected boolean openBrowser(URL url) {
+        if (url != null) {
+			try {
+                url = Platform.asLocalURL(url);
+            } catch (IOException e) {
+                return false;
+            }
+		}
+        if (url == null) {
+			return false;
+		}
+        openLink(url.toString());
+        return true;
+    }
+
+    /**
+     * Sets the styled text's bold ranges
+     */
+    protected void setBoldRanges(StyledText styledText, int[][] boldRanges) {
+        for (int i = 0; i < boldRanges.length; i++) {
+            StyleRange r = new StyleRange(boldRanges[i][0], boldRanges[i][1],
+                    null, null, SWT.BOLD);
+            styledText.setStyleRange(r);
+        }
+    }
+
+    /**
+     * Sets the styled text's link (blue) ranges
+     */
+    protected void setLinkRanges(StyledText styledText, int[][] linkRanges) {
+        Color fg = JFaceColors.getHyperlinkText(styledText.getShell()
+                .getDisplay());
+        for (int i = 0; i < linkRanges.length; i++) {
+            StyleRange r = new StyleRange(linkRanges[i][0], linkRanges[i][1],
+                    fg, null);
+            styledText.setStyleRange(r);
+        }
+    }
+
+    /**
+     * Scan the contents of the about text
+     */
+    protected AboutItem scan(String s) {
+        ArrayList linkRanges = new ArrayList();
+        ArrayList links = new ArrayList();
+        
+        // slightly modified version of jface url detection
+        // see org.eclipse.jface.text.hyperlink.URLHyperlinkDetector
+        
+		int urlSeparatorOffset= s.indexOf("://"); //$NON-NLS-1$
+		while(urlSeparatorOffset >= 0) {
+	
+			boolean startDoubleQuote= false;
+	
+			// URL protocol (left to "://")
+			int urlOffset= urlSeparatorOffset;
+			char ch;
+			do {
+				urlOffset--;
+				ch= ' ';
+				if (urlOffset > -1)
+					ch= s.charAt(urlOffset);
+				startDoubleQuote= ch == '"';
+			} while (Character.isUnicodeIdentifierStart(ch));
+			urlOffset++;
+			
+	
+			// Right to "://"
+			StringTokenizer tokenizer= new StringTokenizer(s.substring(urlSeparatorOffset + 3), " \t\n\r\f<>", false); //$NON-NLS-1$
+			if (!tokenizer.hasMoreTokens())
+				return null;
+	
+			int urlLength= tokenizer.nextToken().length() + 3 + urlSeparatorOffset - urlOffset;
+	
+			if (startDoubleQuote) {
+				int endOffset= -1;
+				int nextDoubleQuote= s.indexOf('"', urlOffset);
+				int nextWhitespace= s.indexOf(' ', urlOffset);
+				if (nextDoubleQuote != -1 && nextWhitespace != -1)
+					endOffset= Math.min(nextDoubleQuote, nextWhitespace);
+				else if (nextDoubleQuote != -1)
+					endOffset= nextDoubleQuote;
+				else if (nextWhitespace != -1)
+					endOffset= nextWhitespace;
+				if (endOffset != -1)
+					urlLength= endOffset - urlOffset;
+			}
+			
+			linkRanges.add(new int[] { urlOffset, urlLength });
+			links.add(s.substring(urlOffset, urlOffset+urlLength));
+			
+			urlSeparatorOffset= s.indexOf("://", urlOffset+urlLength+1); //$NON-NLS-1$
+		}
+        return new AboutItem(s, (int[][]) linkRanges.toArray(new int[linkRanges
+                .size()][2]), (String[]) links
+                .toArray(new String[links.size()]));
+    }
+    
+    /*
+     * (non-Javadoc)
+     * @see org.eclipse.jface.dialogs.Dialog#isResizable()
+     */
+    protected boolean isResizable() {
+    	return true;
+    }
+}
Index: src/org/eclipse/imp/preferences/fields/details/DetailsDialogForRadioGroupFields.java
===================================================================
--- src/org/eclipse/imp/preferences/fields/details/DetailsDialogForRadioGroupFields.java	(revision 21620)
+++ src/org/eclipse/imp/preferences/fields/details/DetailsDialogForRadioGroupFields.java	(working copy)
@@ -32,10 +32,8 @@
 import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Shell;
-import org.eclipse.ui.internal.dialogs.ProductInfoDialog;
 
-
-public class DetailsDialogForRadioGroupFields extends ProductInfoDialog {
+public class DetailsDialogForRadioGroupFields extends AbstractDetailsDialog {
 
 	Shell parent = null;
 	RadioGroupFieldEditor field = null;
Index: src/org/eclipse/imp/preferences/fields/details/DetailsDialogForBooleanFields.java
===================================================================
--- src/org/eclipse/imp/preferences/fields/details/DetailsDialogForBooleanFields.java	(revision 21620)
+++ src/org/eclipse/imp/preferences/fields/details/DetailsDialogForBooleanFields.java	(working copy)
@@ -32,10 +32,8 @@
 import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Shell;
-import org.eclipse.ui.internal.dialogs.ProductInfoDialog;
 
-
-public class DetailsDialogForBooleanFields extends ProductInfoDialog {
+public class DetailsDialogForBooleanFields extends AbstractDetailsDialog {
 
 	Shell parent = null;
 	BooleanFieldEditor field = null;
Index: src/org/eclipse/imp/preferences/fields/details/DetailsDialogForColorFields.java
===================================================================
--- src/org/eclipse/imp/preferences/fields/details/DetailsDialogForColorFields.java	(revision 21620)
+++ src/org/eclipse/imp/preferences/fields/details/DetailsDialogForColorFields.java	(working copy)
@@ -31,9 +31,8 @@
 import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Shell;
-import org.eclipse.ui.internal.dialogs.ProductInfoDialog;
 
-public class DetailsDialogForColorFields extends ProductInfoDialog {
+public class DetailsDialogForColorFields extends AbstractDetailsDialog {
 
 	Shell parent = null;
 	ColorFieldEditor field = null;
Index: src/org/eclipse/imp/preferences/fields/details/DetailsDialogForStringFields.java
===================================================================
--- src/org/eclipse/imp/preferences/fields/details/DetailsDialogForStringFields.java	(revision 21620)
+++ src/org/eclipse/imp/preferences/fields/details/DetailsDialogForStringFields.java	(working copy)
@@ -32,10 +32,8 @@
 import org.eclipse.swt.widgets.Control;
 import org.eclipse.swt.widgets.Label;
 import org.eclipse.swt.widgets.Shell;
-import org.eclipse.ui.internal.dialogs.ProductInfoDialog;
 
-
-public class DetailsDialogForStringFields extends ProductInfoDialog {
+public class DetailsDialogForStringFields extends AbstractDetailsDialog {
 
 	Shell parent = null;
 	StringFieldEditor field = null;
Index: .settings/org.eclipse.jdt.core.prefs
===================================================================
--- .settings/org.eclipse.jdt.core.prefs	(revision 20869)
+++ .settings/org.eclipse.jdt.core.prefs	(working copy)
@@ -1,4 +1,4 @@
-#Wed Oct 18 15:08:27 EDT 2006
+#Thu Aug 21 16:48:50 BST 2008
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
@@ -7,6 +7,65 @@
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=ignore
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=ignore
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=ignore
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=ignore
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=ignore
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=ignore
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=ignore
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=ignore
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5
