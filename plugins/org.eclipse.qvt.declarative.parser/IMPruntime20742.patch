### Eclipse Workspace Patch 1.0
#P org.eclipse.imp.smapifier
Index: plugin.properties
===================================================================
Index: build.properties
===================================================================
--- build.properties	(revision 20550)
+++ build.properties	(working copy)
@@ -3,4 +3,5 @@
 bin.includes = META-INF/,\
                .,\
                plugin.xml,\
-               bin/
+               bin/,\
+               plugin.properties
Index: META-INF/MANIFEST.MF
===================================================================
--- META-INF/MANIFEST.MF	(revision 20550)
+++ META-INF/MANIFEST.MF	(working copy)
@@ -12,6 +12,7 @@
  org.eclipse.imp.smapi,
  org.eclipse.imp.runtime
 Eclipse-LazyStart: true
+Bundle-ActivationPolicy: lazy
 Export-Package: org.eclipse.imp.smapifier.actions,
  org.eclipse.imp.smapifier.builder
 Bundle-Vendor: mvaziri@us.ibm.com
Index: .classpath
===================================================================
--- .classpath	(revision 20550)
+++ .classpath	(working copy)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: plugin.xml
===================================================================
--- plugin.xml	(revision 20550)
+++ plugin.xml	(working copy)
@@ -17,7 +17,7 @@
       <runtime>
          <run class="org.eclipse.imp.smapifier.builder.SmapiProjectNature"/>
       </runtime>
-      <builder id="org.eclipse.imp.smapifier.builder.SmapieBuilder"/>
+      <builder id="org.eclipse.imp.smapifier.SmapieBuilder"/>
       <requires-nature id="org.eclipse.jdt.core.javanature"/>
    </extension>
    
Index: .settings/org.eclipse.jdt.core.prefs
===================================================================
--- .settings/org.eclipse.jdt.core.prefs	(revision 20550)
+++ .settings/org.eclipse.jdt.core.prefs	(working copy)
@@ -1,4 +1,4 @@
-#Tue Nov 13 14:07:40 EST 2007
+#Thu Aug 21 17:37:04 BST 2008
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
@@ -7,6 +7,65 @@
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=ignore
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=ignore
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=ignore
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5
#P org.eclipse.imp.smapi
Index: META-INF/MANIFEST.MF
===================================================================
--- META-INF/MANIFEST.MF	(revision 20550)
+++ META-INF/MANIFEST.MF	(working copy)
@@ -5,6 +5,7 @@
 Bundle-Version: 0.1.86
 Bundle-Localization: plugin
 Eclipse-LazyStart: true
+Bundle-ActivationPolicy: lazy
 Export-Package: org.eclipse.imp.smapi
 Require-Bundle: org.junit,
  com.ibm.wala.shrike
Index: build.properties
===================================================================
--- build.properties	(revision 20550)
+++ build.properties	(working copy)
@@ -1,6 +1,7 @@
 bin.includes = META-INF/,\
                bin/,\
-			   .
+               .,\
+               plugin.properties
 src.includes = .cvsignore,\
                .classpath,\
                .project,\
@@ -7,4 +8,4 @@
                META-INF/,\
                build.properties,\
                src/
-source.. = src/
\ No newline at end of file
+source.. = src/
Index: .classpath
===================================================================
--- .classpath	(revision 20550)
+++ .classpath	(working copy)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: .settings/org.eclipse.jdt.core.prefs
===================================================================
--- .settings/org.eclipse.jdt.core.prefs	(revision 20550)
+++ .settings/org.eclipse.jdt.core.prefs	(working copy)
@@ -1,4 +1,4 @@
-#Tue Nov 13 14:07:22 EST 2007
+#Thu Aug 21 16:49:25 BST 2008
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
@@ -7,6 +7,65 @@
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=ignore
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=ignore
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5
Index: plugin.properties
===================================================================
#P org.eclipse.imp.runtime
Index: plugin.properties
===================================================================
Index: plugin.xml
===================================================================
--- plugin.xml	(revision 20755)
+++ plugin.xml	(working copy)
@@ -62,6 +62,10 @@
             markerSeverity="1"
             name="org.eclipse.imp.editor.parseAnnotation"
             super="org.eclipse.ui.workbench.texteditor.error"/>
+      <type
+            markerSeverity="1"
+            name="org.eclipse.imp.runtime.occurrenceAnnotation"
+            super="org.eclipse.ui.workbench.texteditor.error"/>
    </extension>
    <extension
          point="org.eclipse.ui.editors.markerAnnotationSpecification">
Index: .classpath
===================================================================
--- .classpath	(revision 20755)
+++ .classpath	(working copy)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: META-INF/MANIFEST.MF
===================================================================
--- META-INF/MANIFEST.MF	(revision 20755)
+++ META-INF/MANIFEST.MF	(working copy)
@@ -33,6 +33,7 @@
  com.ibm.icu,
  org.eclipse.help
 Eclipse-LazyStart: true
+Bundle-ActivationPolicy: lazy
 Export-Package: org.eclipse.imp.builder,
  org.eclipse.imp.core,
  org.eclipse.imp.editor,
Index: build.properties
===================================================================
--- build.properties	(revision 20755)
+++ build.properties	(working copy)
@@ -3,5 +3,6 @@
 bin.includes = META-INF/,\
                .,\
                plugin.xml,\
-               icons/
+               icons/,\
+               plugin.properties
 src.includes = icons/
Index: src/org/eclipse/imp/language/LanguageRegistry.java
===================================================================
--- src/org/eclipse/imp/language/LanguageRegistry.java	(revision 20755)
+++ src/org/eclipse/imp/language/LanguageRegistry.java	(working copy)
@@ -25,6 +25,7 @@
 import java.util.Map;
 
 import org.eclipse.core.runtime.IConfigurationElement;
+import org.eclipse.core.runtime.IExtension;
 import org.eclipse.core.runtime.IExtensionPoint;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.InvalidRegistryObjectException;
@@ -38,6 +39,7 @@
 import org.eclipse.swt.widgets.Display;
 import org.eclipse.ui.IEditorDescriptor;
 import org.eclipse.ui.IEditorInput;
+import org.eclipse.ui.IEditorMatchingStrategy;
 import org.eclipse.ui.IFileEditorMapping;
 import org.eclipse.ui.PlatformUI;
 import org.eclipse.ui.internal.registry.EditorDescriptor;
@@ -317,7 +319,7 @@
                     FileEditorMapping fem= (FileEditorMapping) mapping;
 	        }
 	        IEditorDescriptor defaultEditor= mapping.getDefaultEditor();
-                FileEditorMapping fem= (FileEditorMapping) mapping;
+            FileEditorMapping fem= (FileEditorMapping) mapping;
 	        if (defaultEditor == null || defaultEditor.getId().equals("")) {
 	            fem.setDefaultEditor((EditorDescriptor) universalEditor);
 	        } else {
@@ -331,6 +333,24 @@
 	        	    	break;
 	        	    }
 	        	}
+	        	if (!gotIt) {
+	        		for (IEditorDescriptor editor : fem.getEditors()) {	// Search for an implicit copy of a derived UniversalEditor
+		        		EditorDescriptor editorDescriptor = (EditorDescriptor) editor;
+						String className = editorDescriptor.getClassName();
+						IConfigurationElement configurationElement = editorDescriptor.getConfigurationElement();
+						IExtension declaringExtension = configurationElement.getDeclaringExtension();
+						String namespaceIdentifier = declaringExtension.getNamespaceIdentifier();
+						Bundle bundle = Platform.getBundle(namespaceIdentifier);
+		        		try {
+							Class<?> editorClass = bundle.loadClass(className);
+			        		if (UniversalEditor.class.isAssignableFrom(editorClass)) {
+			        			gotIt = true;
+			        			break;
+			        		}
+						} catch (ClassNotFoundException e) {
+						}
+		        	}
+	        	}
 	        	if (!gotIt)
 	        		fem.addEditor((EditorDescriptor) universalEditor);
 	        }
Index: src/org/eclipse/imp/wizards/NewProjectWizardSecondPage.java
===================================================================
--- src/org/eclipse/imp/wizards/NewProjectWizardSecondPage.java	(revision 20755)
+++ src/org/eclipse/imp/wizards/NewProjectWizardSecondPage.java	(working copy)
@@ -53,7 +53,6 @@
 import org.eclipse.jdt.core.IClasspathEntry;
 import org.eclipse.jdt.core.IJavaProject;
 import org.eclipse.jdt.core.JavaCore;
-import org.eclipse.jdt.internal.corext.util.JavaModelUtil;
 import org.eclipse.jdt.internal.corext.util.Messages;
 import org.eclipse.jdt.internal.ui.dialogs.StatusInfo;
 import org.eclipse.jdt.internal.ui.util.CoreUtility;
@@ -129,7 +128,7 @@
             if (compliance != null) {
                 IJavaProject project= JavaCore.create(fCurrProject);
                 Map options= project.getOptions(false);
-                JavaModelUtil.setCompilanceOptions(options, compliance);
+                JavaCore.setComplianceOptions(compliance, options);
                 project.setOptions(options);
             }
         } finally {
Index: src/org/eclipse/imp/utils/HTMLPrinter.java
===================================================================
--- src/org/eclipse/imp/utils/HTMLPrinter.java	(revision 20755)
+++ src/org/eclipse/imp/utils/HTMLPrinter.java	(working copy)
@@ -212,19 +212,7 @@
      * Formats several messages as HTML text.
      */
     public static String formatMultipleMessages(List/*<String>*/ messages) {
-        if (true) { // until we hook in the HTML-enabled hover viewer
-            StringBuffer buff= new StringBuffer();
-            buff.append("Multiple messages:\n");
-            for(Iterator iter= messages.iterator(); iter.hasNext();) {
-        	String msg= (String) iter.next();
-        	buff.append("  ");
-        	buff.append(msg);
-        	if (iter.hasNext())
-        	    buff.append('\n');
-            }
-            return buff.toString();
-        }
-        StringBuffer buffer= new StringBuffer();
+    	StringBuffer buffer= new StringBuffer();
         addPageProlog(buffer);
         addParagraph(buffer, convertToHTMLContent("There are multiple markers on this line."));
         startBulletList(buffer);
@@ -240,8 +228,6 @@
      * Formats a message as HTML text.
      */
     public static String formatSingleMessage(String message) {
-        if (true) // until we hook in the HTML-enabled hover viewer
-            return message;
         StringBuffer buffer= new StringBuffer();
         addPageProlog(buffer);
         addParagraph(buffer, convertToHTMLContent(message));
Index: src/org/eclipse/imp/editor/AnnotationHoverBase.java
===================================================================
--- src/org/eclipse/imp/editor/AnnotationHoverBase.java	(revision 20755)
+++ src/org/eclipse/imp/editor/AnnotationHoverBase.java	(working copy)
@@ -166,8 +166,6 @@
      * Formats a message as HTML text.
      */
     public static String formatSingleMessage(String message) {
-        if (true) // until we hook in the HTML-enabled hover viewer
-            return message;
         StringBuffer buffer= new StringBuffer();
         HTMLPrinter.addPageProlog(buffer);
         HTMLPrinter.addParagraph(buffer, HTMLPrinter.convertToHTMLContent(message));
@@ -179,19 +177,6 @@
      * Formats several messages as HTML text.
      */
     public static String formatMultipleMessages(List messages) {
-        if (true) { // until we hook in the HTML-enabled hover viewer
-            StringBuffer buff= new StringBuffer();
-    
-            buff.append("Multiple messages:\n");
-            for(Iterator iter= messages.iterator(); iter.hasNext();) {
-        	String msg= (String) iter.next();
-        	buff.append("  ");
-        	buff.append(msg);
-        	if (iter.hasNext())
-        	    buff.append('\n');
-            }
-            return buff.toString();
-        }
         StringBuffer buffer= new StringBuffer();
         HTMLPrinter.addPageProlog(buffer);
         HTMLPrinter.addParagraph(buffer, HTMLPrinter.convertToHTMLContent("Multiple messages at this line"));
Index: src/org/eclipse/imp/editor/internal/PresentationController.java
===================================================================
--- src/org/eclipse/imp/editor/internal/PresentationController.java	(revision 20755)
+++ src/org/eclipse/imp/editor/internal/PresentationController.java	(working copy)
@@ -14,6 +14,8 @@
 
 import java.io.PrintStream;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Stack;
@@ -28,6 +30,8 @@
 import org.eclipse.imp.preferences.PreferenceCache;
 import org.eclipse.imp.services.ITokenColorer;
 import org.eclipse.imp.utils.ConsoleUtil;
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.IDocument;
 import org.eclipse.jface.text.IRegion;
 import org.eclipse.jface.text.Region;
 import org.eclipse.jface.text.TextAttribute;
@@ -157,8 +161,18 @@
         }
     }
 
-    private void submitTextPresentation(final TextPresentation presentation) {
-
+    private void submitTextPresentation(final TextPresentation uncheckedPresentation) {
+    	int charCount = 0;
+    	if (fSourceViewer != null) {		
+    		IDocument document = fSourceViewer.getDocument();
+			if (document != null)			// EDW 27 Sep 2008 May be null after file deleted
+				charCount = document.getLength();
+    	}
+    	final TextPresentation presentation;
+    	if (!checkPresentation(uncheckedPresentation, charCount))
+			presentation = correctPresentation(uncheckedPresentation, charCount);
+    	else
+    		presentation = uncheckedPresentation;
         Display.getDefault().asyncExec(new Runnable() {
             public void run() {
             	
@@ -163,11 +177,11 @@
             public void run() {
             	
             	// SMS 16 Sep 2008
-            	int charCount;
-            	if (fSourceViewer != null) {
-            		charCount = fSourceViewer.getDocument().getLength();
-            	} else {
-            		charCount = 0;
+            	int charCount = 0;
+            	if (fSourceViewer != null) {		
+            		IDocument document = fSourceViewer.getDocument();
+					if (document != null)			// EDW 27 Sep 2008 May be null after file deleted
+						charCount = document.getLength();
             	}
             	
             	// Attempt to head off exception due to final range extending beyond
@@ -245,4 +259,78 @@
             }
         });
     }
+
+	private boolean checkPresentation(TextPresentation presentation, int charCount) {		// EDW
+		Iterator presIt = presentation.getAllStyleRangeIterator();
+		int end = -1;
+		while (presIt.hasNext()) {
+			StyleRange nextRange = (StyleRange) presIt.next();
+        	int start = nextRange.start;
+           	int length = nextRange.length;
+            if (start < end) {
+        		System.out.println("Unexpected style start " + start + ":" + length + ":" + (start + length) + "/" + charCount);
+        		return false;
+        	}
+        	if (length < 1) {
+        		System.out.println("Unexpected style length " + start + ":" + length + ":" + (start + length) + "/" + charCount);
+        		return false;
+        	}
+        	end = start + length;      	
+        	if (end > charCount) {
+        		System.out.println("Unexpected style end " + start + ":" + length + ":" + (start + length) + "/" + charCount);
+        		return false;
+        	}
+		}
+		return true;
+	}
+
+	private TextPresentation correctPresentation(TextPresentation presentation, int charCount) {		// EDW
+		List<StyleRange> ranges = new ArrayList<StyleRange>();
+		Iterator presIt = presentation.getAllStyleRangeIterator();
+		for (int styleNumber = 0; presIt.hasNext(); styleNumber++) {
+			StyleRange range = (StyleRange) presIt.next();
+        	int start = range.start;
+        	int length = range.length;
+    		if (length <= 0)
+        		System.out.println("Ignored -ve length style " + styleNumber + ": " + range.start + ":" + range.length + ":" + (range.start + range.length) + "/" + charCount);
+    		else if (start >= charCount)
+        		System.out.println("Ignored past-end style " + styleNumber + ": " + range.start + ":" + range.length + ":" + (range.start + range.length) + "/" + charCount);
+    		else {
+        		int end = start + length;
+        		if (end > charCount) {
+            		System.out.println("Truncated over-end style " + styleNumber + ": " + range.start + ":" + range.length + ":" + (range.start + range.length) + "/" + charCount);
+            		range.length = charCount - start;
+        		}
+        		ranges.add(range);
+        	}
+		}
+		Collections.sort(ranges, new Comparator<StyleRange>()
+		{
+			public int compare(StyleRange o1, StyleRange o2) {
+				return o1.start - o2.start;
+			}
+		});
+		IDocument document = fSourceViewer.getDocument();
+		TextPresentation newPresentation = new TextPresentation();
+		int iMax = ranges.size();
+		for (int i = 0; i < iMax; i++) {
+			StyleRange thisRange = ranges.get(i);
+			if ((i+1) < iMax) {
+				StyleRange nextRange = ranges.get(i+1);
+        		int end = thisRange.start + thisRange.length;
+				if (end > nextRange.start) {
+            		try {
+						System.out.println("Truncated over-lap style " + i + " " +
+								thisRange.start + ":" + thisRange.length + ":" + (thisRange.start + thisRange.length) + ":'" + document.get(thisRange.start, thisRange.length) + "' " +
+								nextRange.start + ":" + nextRange.length + ":" + (nextRange.start + nextRange.length) + ":'" + document.get(nextRange.start, nextRange.length) + "'");
+					} catch (BadLocationException e) {
+						e.printStackTrace();
+					}
+					thisRange.length = nextRange.start - thisRange.start;
+				}
+			}
+			newPresentation.addStyleRange(thisRange);
+		}
+		return newPresentation;
+	}
 }
Index: src/org/eclipse/imp/editor/ParserScheduler.java
===================================================================
--- src/org/eclipse/imp/editor/ParserScheduler.java	(revision 20755)
+++ src/org/eclipse/imp/editor/ParserScheduler.java	(working copy)
@@ -68,8 +68,11 @@
 
         IEditorInput editorInput= fEditorPart.getEditorInput();
         try {
-            IDocument document= fDocumentProvider.getDocument(editorInput);
-
+            IDocument document = fDocumentProvider.getDocument(editorInput);
+            if (document == null) {				// EDW 29 Sep 2008
+                /* Editor was deleted */
+                return Status.OK_STATUS;
+            }
             if (PreferenceCache.emitMessages)
                 RuntimePlugin.getInstance().writeInfoMsg(
                         "Parsing language " + fParseController.getLanguage().getName() + " for input " + editorInput.getName());
Index: src/org/eclipse/imp/preferences/PreferenceValueParsersym.java
===================================================================
--- src/org/eclipse/imp/preferences/PreferenceValueParsersym.java	(revision 0)
+++ src/org/eclipse/imp/preferences/PreferenceValueParsersym.java	(revision 0)
@@ -0,0 +1,227 @@
+
+////////////////////////////////////////////////////////////////////////////////
+// Copyright (c) 2007 IBM Corporation.
+// All rights reserved. This program and the accompanying materials
+// are made available under the terms of the Eclipse Public License v1.0
+// which accompanies this distribution, and is available at
+// http://www.eclipse.org/legal/epl-v10.html
+//
+//Author: Robert Fuhrer (rfuhrer@watson.ibm.com)
+////////////////////////////////////////////////////////////////////////////////
+
+package org.eclipse.imp.preferences;
+
+public interface PreferenceValueParsersym {
+    public final static int
+      Char_a = 1,
+      Char_b = 2,
+      Char_c = 3,
+      Char_d = 4,
+      Char_e = 5,
+      Char_f = 6,
+      Char_g = 7,
+      Char_h = 8,
+      Char_i = 9,
+      Char_j = 10,
+      Char_k = 11,
+      Char_l = 12,
+      Char_m = 13,
+      Char_n = 14,
+      Char_o = 15,
+      Char_p = 16,
+      Char_q = 17,
+      Char_r = 18,
+      Char_s = 19,
+      Char_t = 20,
+      Char_u = 21,
+      Char_v = 22,
+      Char_w = 23,
+      Char_x = 24,
+      Char_y = 25,
+      Char_z = 26,
+      Char__ = 65,
+      Char_A = 27,
+      Char_B = 28,
+      Char_C = 29,
+      Char_D = 30,
+      Char_E = 31,
+      Char_F = 32,
+      Char_G = 33,
+      Char_H = 34,
+      Char_I = 35,
+      Char_J = 36,
+      Char_K = 37,
+      Char_L = 38,
+      Char_M = 39,
+      Char_N = 40,
+      Char_O = 41,
+      Char_P = 42,
+      Char_Q = 43,
+      Char_R = 44,
+      Char_S = 45,
+      Char_T = 46,
+      Char_U = 47,
+      Char_V = 48,
+      Char_W = 49,
+      Char_X = 50,
+      Char_Y = 51,
+      Char_Z = 52,
+      Char_0 = 53,
+      Char_1 = 54,
+      Char_2 = 55,
+      Char_3 = 56,
+      Char_4 = 57,
+      Char_5 = 58,
+      Char_6 = 59,
+      Char_7 = 60,
+      Char_8 = 61,
+      Char_9 = 62,
+      Char_DoubleQuote = 66,
+      Char_SingleQuote = 67,
+      Char_Percent = 68,
+      Char_VerticalBar = 69,
+      Char_Exclamation = 70,
+      Char_AtSign = 71,
+      Char_BackQuote = 72,
+      Char_Tilde = 73,
+      Char_Sharp = 74,
+      Char_DollarSign = 75,
+      Char_Ampersand = 76,
+      Char_Caret = 77,
+      Char_Colon = 63,
+      Char_SemiColon = 78,
+      Char_BackSlash = 79,
+      Char_LeftBrace = 64,
+      Char_RightBrace = 95,
+      Char_LeftBracket = 80,
+      Char_RightBracket = 81,
+      Char_QuestionMark = 82,
+      Char_Comma = 83,
+      Char_Dot = 84,
+      Char_LessThan = 85,
+      Char_GreaterThan = 86,
+      Char_Plus = 87,
+      Char_Minus = 88,
+      Char_Slash = 89,
+      Char_Star = 90,
+      Char_LeftParen = 91,
+      Char_RightParen = 92,
+      Char_Equal = 93,
+      Char_Space = 94,
+      Char_CtlCharNotWS = 97,
+      Char_HT = 98,
+      Char_LF = 99,
+      Char_FF = 100,
+      Char_CR = 101,
+      Char_AfterASCII = 102,
+      Char_EOF = 96;
+
+    public final static String orderedTerminalSymbols[] = {
+                 "",
+                 "a",
+                 "b",
+                 "c",
+                 "d",
+                 "e",
+                 "f",
+                 "g",
+                 "h",
+                 "i",
+                 "j",
+                 "k",
+                 "l",
+                 "m",
+                 "n",
+                 "o",
+                 "p",
+                 "q",
+                 "r",
+                 "s",
+                 "t",
+                 "u",
+                 "v",
+                 "w",
+                 "x",
+                 "y",
+                 "z",
+                 "A",
+                 "B",
+                 "C",
+                 "D",
+                 "E",
+                 "F",
+                 "G",
+                 "H",
+                 "I",
+                 "J",
+                 "K",
+                 "L",
+                 "M",
+                 "N",
+                 "O",
+                 "P",
+                 "Q",
+                 "R",
+                 "S",
+                 "T",
+                 "U",
+                 "V",
+                 "W",
+                 "X",
+                 "Y",
+                 "Z",
+                 "0",
+                 "1",
+                 "2",
+                 "3",
+                 "4",
+                 "5",
+                 "6",
+                 "7",
+                 "8",
+                 "9",
+                 "Colon",
+                 "LeftBrace",
+                 "_",
+                 "DoubleQuote",
+                 "SingleQuote",
+                 "Percent",
+                 "VerticalBar",
+                 "Exclamation",
+                 "AtSign",
+                 "BackQuote",
+                 "Tilde",
+                 "Sharp",
+                 "DollarSign",
+                 "Ampersand",
+                 "Caret",
+                 "SemiColon",
+                 "BackSlash",
+                 "LeftBracket",
+                 "RightBracket",
+                 "QuestionMark",
+                 "Comma",
+                 "Dot",
+                 "LessThan",
+                 "GreaterThan",
+                 "Plus",
+                 "Minus",
+                 "Slash",
+                 "Star",
+                 "LeftParen",
+                 "RightParen",
+                 "Equal",
+                 "Space",
+                 "RightBrace",
+                 "EOF",
+                 "CtlCharNotWS",
+                 "HT",
+                 "LF",
+                 "FF",
+                 "CR",
+                 "AfterASCII"
+             };
+
+    public final static int numTokenKinds = orderedTerminalSymbols.length;
+    public final static boolean isValidForParser = true;
+}
Index: src/org/eclipse/imp/preferences/PreferenceValueParser.l
===================================================================
--- src/org/eclipse/imp/preferences/PreferenceValueParser.l	(revision 0)
+++ src/org/eclipse/imp/preferences/PreferenceValueParser.l	(revision 0)
@@ -0,0 +1,85 @@
+
+Options in effect for C:/Development/QvtDeclarative/plugins/org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceValueParser.g:
+
+    ACTION-BLOCK=("C:\Development\QvtDeclarative\plugins\org.eclipse.imp.runtime\src\org\eclipse\imp\preferences\PreferenceValueParser.java","/.","./")
+
+    AST-DIRECTORY=""  AST-TYPE="ASTNode"  NOATTRIBUTES  AUTOMATIC-AST=NESTED  
+    NOBACKTRACK  BYTE  CONFLICTS  
+    DAT-DIRECTORY="C:\Development\QvtDeclarative\plugins\org.eclipse.imp.runtime\src\org\eclipse\imp\preferences\"
+    
+    DAT-FILE="C:\Development\QvtDeclarative\plugins\org.eclipse.imp.runtime\src\org\eclipse\imp\preferences\PreferenceValueParserdcl.data"
+    
+    DCL-FILE="C:\Development\QvtDeclarative\plugins\org.eclipse.imp.runtime\src\org\eclipse\imp\preferences\PreferenceValueParserdcl.java"
+    NODEBUG  
+    DEF-FILE="C:\Development\QvtDeclarative\plugins\org.eclipse.imp.runtime\src\org\eclipse\imp\preferences\PreferenceValueParserdef.java"
+    NOEDIT  NOERROR-MAPS  ESCAPE='$'  
+    EXPORT-TERMINALS=("C:\Development\QvtDeclarative\plugins\org.eclipse.imp.runtime\src\org\eclipse\imp\preferences\PreferenceValueParserexp.java","","")
+    EXTENDS-PARSETABLE  FACTORY="new "  FILE-PREFIX="PreferenceValueParser"  
+    NOFIRST  NOFOLLOW  NOGLR  NOGOTO-DEFAULT  
+    GRM-FILE="C:/Development/QvtDeclarative/plugins/org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceValueParser.g"
+    
+    IMP-FILE="C:\Development\QvtDeclarative\plugins\org.eclipse.imp.runtime\src\org\eclipse\imp\preferences\PreferenceValueParserimp.java"
+    
+    INCLUDE-DIRECTORY="C:\Development\QvtDeclarative\tools\lpg.runtime.java\templates;C:\Development.NoBackup\QVT\Workspace3.4\org.eclipse.imp.lpg.metatooling\templates;C:\Development\QvtDeclarative\tools\lpg.runtime.java\include;"
+    LALR=1  LEGACY  NOLIST  MARGIN=4  MAX-CASES=1024  NAMES=OPTIMIZED  
+    NONT-CHECK  OR_MARKER='|'  
+    OUT-DIRECTORY="C:\Development\QvtDeclarative\plugins\org.eclipse.imp.runtime\src\org\eclipse\imp\preferences\"
+    PACKAGE="org.eclipse.imp.preferences"  PARENT-SAVED  
+    PARSETABLE-INTERFACES="lpg.runtime.ParseTable"  PREFIX="Char_"  PRIORITY  
+    PROGRAMMING_LANGUAGE=JAVA  
+    PRS-FILE="C:\Development\QvtDeclarative\plugins\org.eclipse.imp.runtime\src\org\eclipse\imp\preferences\PreferenceValueParserprs.java"
+    NOQUIET  READ-REDUCE  REMAP-TERMINALS  NOSCOPES  NOSERIALIZE  
+    NOSHIFT-DEFAULT  NOSINGLE-PRODUCTIONS  NOSOFT-KEYWORDS  NOSTATES  SUFFIX=""
+    SYM-FILE="C:\Development\QvtDeclarative\plugins\org.eclipse.imp.runtime\src\org\eclipse\imp\preferences\PreferenceValueParsersym.java"
+    TAB-FILE="PreferenceValueParser.t"  TABLE  TEMPLATE=""  TRACE=CONFLICTS  
+    VARIABLES  NOVERBOSE  VISITOR=PREORDER  VISITOR-TYPE="Visitor"  WARNINGS  
+    NOXREF  
+
+C:/Development/QvtDeclarative/plugins/org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceValueParser.g:143:5:143:16:3461:3472: Informative: The terminal CtlCharNotWS is useless.
+C:/Development/QvtDeclarative/plugins/org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceValueParser.g:144:5:144:6:3479:3480: Informative: The terminal HT is useless.
+C:/Development/QvtDeclarative/plugins/org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceValueParser.g:145:5:145:6:3487:3488: Informative: The terminal LF is useless.
+C:/Development/QvtDeclarative/plugins/org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceValueParser.g:146:5:146:6:3495:3496: Informative: The terminal FF is useless.
+C:/Development/QvtDeclarative/plugins/org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceValueParser.g:147:5:147:6:3503:3504: Informative: The terminal CR is useless.
+C:/Development/QvtDeclarative/plugins/org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceValueParser.g:148:5:148:14:3511:3520: Informative: The terminal AfterASCII is useless.
+
+
+C:/Development/QvtDeclarative/plugins/org.eclipse.imp.runtime/src/org/eclipse/imp/preferences/PreferenceValueParser.g:152:5:152:9:3543:3547: Informative: Grammar is  LALR(1).
+
+Number of Terminals: 102
+Number of Nonterminals: 43
+Number of Productions: 181
+Number of Items: 376
+Number of States: 12
+Number of Shift actions: 10
+Number of Goto actions: 13
+Number of Shift/Reduce actions: 578
+Number of Goto/Reduce actions: 219
+Number of Reduce actions: 11
+Number of Shift-Reduce conflicts: 0
+Number of Reduce-Reduce conflicts: 0
+
+Number of entries in base Action Table: 244
+Additional space required for compaction of Action Table: 23.3%
+
+Number of unique terminal states: 11
+Number of Shift actions saved by merging: 94
+Number of Conflict points saved by merging: 0
+Number of Reduce actions saved by merging: 0
+Number of Reduce saved by default: 10
+
+Number of entries in Terminal Action Table: 506
+Additional space required for compaction of Terminal Table: 17.9%
+
+Actions in Compressed Tables:
+     Number of Shifts: 8
+     Number of Shift/Reduces: 486
+     Number of Gotos: 13
+     Number of Goto/Reduces: 219
+     Number of Reduces: 1
+     Number of Defaults: 5
+
+Parsing Tables storage:
+    Storage required for BASE_CHECK: 181 Bytes
+    Storage required for BASE_ACTION: 966 Bytes
+    Storage required for TERM_CHECK: 605 Bytes
+    Storage required for TERM_ACTION: 1196 Bytes
Index: src/org/eclipse/imp/preferences/PreferenceValueParserprs.java
===================================================================
--- src/org/eclipse/imp/preferences/PreferenceValueParserprs.java	(revision 0)
+++ src/org/eclipse/imp/preferences/PreferenceValueParserprs.java	(revision 0)
@@ -0,0 +1,386 @@
+
+////////////////////////////////////////////////////////////////////////////////
+// Copyright (c) 2007 IBM Corporation.
+// All rights reserved. This program and the accompanying materials
+// are made available under the terms of the Eclipse Public License v1.0
+// which accompanies this distribution, and is available at
+// http://www.eclipse.org/legal/epl-v10.html
+//
+//Author: Robert Fuhrer (rfuhrer@watson.ibm.com)
+////////////////////////////////////////////////////////////////////////////////
+
+package org.eclipse.imp.preferences;
+
+public class PreferenceValueParserprs implements lpg.runtime.ParseTable, PreferenceValueParsersym {
+    public final static int ERROR_SYMBOL = 0;
+    public final int getErrorSymbol() { return ERROR_SYMBOL; }
+
+    public final static int SCOPE_UBOUND = 0;
+    public final int getScopeUbound() { return SCOPE_UBOUND; }
+
+    public final static int SCOPE_SIZE = 0;
+    public final int getScopeSize() { return SCOPE_SIZE; }
+
+    public final static int MAX_NAME_LENGTH = 0;
+    public final int getMaxNameLength() { return MAX_NAME_LENGTH; }
+
+    public final static int NUM_STATES = 12;
+    public final int getNumStates() { return NUM_STATES; }
+
+    public final static int NT_OFFSET = 102;
+    public final int getNtOffset() { return NT_OFFSET; }
+
+    public final static int LA_STATE_OFFSET = 663;
+    public final int getLaStateOffset() { return LA_STATE_OFFSET; }
+
+    public final static int MAX_LA = 1;
+    public final int getMaxLa() { return MAX_LA; }
+
+    public final static int NUM_RULES = 180;
+    public final int getNumRules() { return NUM_RULES; }
+
+    public final static int NUM_NONTERMINALS = 44;
+    public final int getNumNonterminals() { return NUM_NONTERMINALS; }
+
+    public final static int NUM_SYMBOLS = 146;
+    public final int getNumSymbols() { return NUM_SYMBOLS; }
+
+    public final static int SEGMENT_SIZE = 8192;
+    public final int getSegmentSize() { return SEGMENT_SIZE; }
+
+    public final static int START_STATE = 181;
+    public final int getStartState() { return START_STATE; }
+
+    public final static int IDENTIFIER_SYMBOL = 0;
+    public final int getIdentifier_SYMBOL() { return IDENTIFIER_SYMBOL; }
+
+    public final static int EOFT_SYMBOL = 96;
+    public final int getEoftSymbol() { return EOFT_SYMBOL; }
+
+    public final static int EOLT_SYMBOL = 103;
+    public final int getEoltSymbol() { return EOLT_SYMBOL; }
+
+    public final static int ACCEPT_ACTION = 482;
+    public final int getAcceptAction() { return ACCEPT_ACTION; }
+
+    public final static int ERROR_ACTION = 483;
+    public final int getErrorAction() { return ERROR_ACTION; }
+
+    public final static boolean BACKTRACK = false;
+    public final boolean getBacktrack() { return BACKTRACK; }
+
+    public final int getStartSymbol() { return lhs(0); }
+    public final boolean isValidForParser() { return PreferenceValueParsersym.isValidForParser; }
+
+
+    public interface IsNullable {
+        public final static byte isNullable[] = {0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,1,0,0,0,0
+        };
+    };
+    public final static byte isNullable[] = IsNullable.isNullable;
+    public final boolean isNullable(int index) { return isNullable[index] != 0; }
+
+    public interface ProsthesesIndex {
+        public final static byte prosthesesIndex[] = {0,
+            4,5,6,7,8,9,10,11,12,13,
+            14,15,16,17,18,19,20,21,22,23,
+            24,25,26,27,28,29,30,3,36,38,
+            39,31,32,33,34,35,37,2,40,41,
+            42,43,44,1
+        };
+    };
+    public final static byte prosthesesIndex[] = ProsthesesIndex.prosthesesIndex;
+    public final int prosthesesIndex(int index) { return prosthesesIndex[index]; }
+
+    public interface IsKeyword {
+        public final static byte isKeyword[] = {0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0
+        };
+    };
+    public final static byte isKeyword[] = IsKeyword.isKeyword;
+    public final boolean isKeyword(int index) { return isKeyword[index] != 0; }
+
+    public interface BaseCheck {
+        public final static byte baseCheck[] = {0,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,2,1,1,2,1,2,1,1,2,
+            2,2,2,5,0,2,1,1,2,2,
+            1,1,1,2,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1,
+            1,1,1,1,1,1,1,1,1,1
+        };
+    };
+    public final static byte baseCheck[] = BaseCheck.baseCheck;
+    public final int baseCheck(int index) { return baseCheck[index]; }
+    public final static byte rhs[] = baseCheck;
+    public final int rhs(int index) { return rhs[index]; };
+
+    public interface BaseAction {
+        public final static char baseAction[] = {
+            38,28,28,28,28,28,28,28,28,28,
+            28,1,1,2,2,3,3,4,4,5,
+            5,6,6,7,7,8,8,9,9,10,
+            10,11,11,12,12,13,13,14,14,15,
+            15,16,16,17,17,18,18,19,19,20,
+            20,21,21,22,22,23,23,24,24,25,
+            25,26,26,27,27,27,27,27,27,27,
+            27,27,27,27,27,27,27,27,27,27,
+            27,27,27,27,27,27,27,27,27,38,
+            38,32,32,34,33,33,36,36,35,35,
+            35,35,35,35,29,40,40,39,41,41,
+            41,37,37,37,30,42,42,42,31,31,
+            31,31,31,31,31,31,31,31,31,31,
+            31,31,31,31,31,31,31,31,31,31,
+            31,31,31,31,31,31,31,31,43,43,
+            43,43,43,43,43,43,43,43,43,43,
+            43,43,43,43,43,43,43,43,43,43,
+            43,43,43,43,43,43,43,43,43,43,
+            43,97,63,64,65,66,67,68,69,70,
+            71,72,73,74,75,76,77,78,79,80,
+            81,82,83,84,85,86,87,88,111,112,
+            96,99,113,89,90,444,341,259,98,295,
+            97,63,64,65,66,67,68,69,70,71,
+            72,73,74,75,76,77,78,79,80,81,
+            82,83,84,85,86,87,88,111,112,96,
+            99,113,89,90,444,341,259,98,106,192,
+            63,64,65,66,67,68,69,70,71,72,
+            73,74,75,76,77,78,79,80,81,82,
+            83,84,85,86,87,88,111,112,97,99,
+            113,95,501,444,341,498,98,1,63,64,
+            65,66,67,68,69,70,71,72,73,74,
+            75,76,77,78,79,80,81,82,83,84,
+            85,86,87,88,115,116,499,502,483,483,
+            483,483,327,483,483,483,483,483,483,114,
+            117,287,63,64,65,66,67,68,69,70,
+            71,72,73,74,75,76,77,78,79,80,
+            81,82,83,84,85,86,87,88,101,102,
+            483,100,103,445,63,64,65,66,67,68,
+            69,70,71,72,73,74,75,76,77,78,
+            79,80,81,82,83,84,85,86,87,88,
+            108,483,483,483,483,483,483,483,483,483,
+            483,483,292,483,415,382,63,64,65,66,
+            67,68,69,70,71,72,73,74,75,76,
+            77,78,79,80,81,82,83,84,85,86,
+            87,88,109,110,500,483,483,483,483,483,
+            483,483,483,483,483,483,483,483,483,483,
+            483,483,483,483,483,483,483,483,483,483,
+            483,483,483,96,483,483,483,92,483,483,
+            259,483,483
+        };
+    };
+    public final static char baseAction[] = BaseAction.baseAction;
+    public final int baseAction(int index) { return baseAction[index]; }
+    public final static char lhs[] = baseAction;
+    public final int lhs(int index) { return lhs[index]; };
+
+    public interface TermCheck {
+        public final static byte termCheck[] = {0,
+            0,1,2,3,4,5,6,7,8,9,
+            10,11,12,13,14,15,16,17,18,19,
+            20,21,22,23,24,25,26,27,28,29,
+            30,31,32,33,34,35,36,37,38,39,
+            40,41,42,43,44,45,46,47,48,49,
+            50,51,52,53,54,55,56,57,58,59,
+            60,61,62,63,64,65,66,67,68,69,
+            70,71,72,73,74,75,76,77,78,79,
+            80,81,82,83,84,85,86,87,88,89,
+            90,91,92,93,94,95,0,1,2,3,
+            4,5,6,7,8,9,10,11,12,13,
+            14,15,16,17,18,19,20,21,22,23,
+            24,25,26,27,28,29,30,31,32,33,
+            34,35,36,37,38,39,40,41,42,43,
+            44,45,46,47,48,49,50,51,52,53,
+            54,55,56,57,58,59,60,61,62,63,
+            64,65,66,67,68,69,70,71,72,73,
+            74,75,76,77,78,79,80,81,82,83,
+            84,85,86,87,88,89,90,91,92,93,
+            94,0,1,2,3,4,5,6,7,8,
+            9,10,11,12,13,14,15,16,17,18,
+            19,20,21,22,23,24,25,26,27,28,
+            29,30,31,32,33,34,35,36,37,38,
+            39,40,41,42,43,44,45,46,47,48,
+            49,50,51,52,53,54,55,56,57,58,
+            59,60,61,62,63,64,65,66,67,68,
+            69,70,71,72,73,74,75,76,77,78,
+            79,80,81,82,83,84,85,86,87,88,
+            89,90,91,92,93,94,0,1,2,3,
+            4,5,6,7,8,9,10,11,12,13,
+            14,15,16,17,18,19,20,21,22,23,
+            24,25,26,27,28,29,30,31,32,33,
+            34,35,36,37,38,39,40,41,42,43,
+            44,45,46,47,48,49,50,51,52,53,
+            54,55,56,57,58,59,60,61,62,63,
+            64,65,66,67,68,69,70,71,72,73,
+            74,0,76,77,78,79,80,81,82,83,
+            84,85,86,87,88,89,90,91,92,93,
+            94,0,1,2,3,4,5,6,7,8,
+            9,10,11,12,13,14,15,16,17,18,
+            19,20,21,22,23,24,25,26,27,28,
+            29,30,31,32,33,34,35,36,37,38,
+            39,40,41,42,43,44,45,46,47,48,
+            49,50,51,52,53,54,55,56,57,58,
+            59,60,61,62,0,1,2,3,4,5,
+            6,7,8,9,10,11,12,13,14,15,
+            16,17,18,19,20,21,22,23,24,25,
+            26,27,28,29,30,31,32,33,34,35,
+            36,37,38,39,40,41,42,43,44,45,
+            46,47,48,49,50,51,52,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,64,63,0,0,0,0,0,0,
+            0,0,0,0,75,0,0,0,0,0,
+            0,0,0,0,0,0,0,0,0,0,
+            0,0,0,96,0,0,95,0,0,0,
+            0,0,0,0
+        };
+    };
+    public final static byte termCheck[] = TermCheck.termCheck;
+    public final int termCheck(int index) { return termCheck[index]; }
+
+    public interface TermAction {
+        public final static char termAction[] = {0,
+            483,494,496,498,500,502,504,506,508,510,
+            512,514,516,518,520,522,524,526,528,530,
+            532,534,536,538,540,542,544,495,497,499,
+            501,503,505,507,509,511,513,515,517,519,
+            521,523,525,527,529,531,533,535,537,539,
+            541,543,545,484,485,486,487,488,489,490,
+            491,492,493,645,650,662,635,647,642,649,
+            636,637,638,639,660,663,643,644,646,648,
+            653,654,655,656,640,657,658,631,632,641,
+            661,633,634,659,651,652,483,494,496,498,
+            500,502,504,506,508,510,512,514,516,518,
+            520,522,524,526,528,530,532,534,536,538,
+            540,542,544,495,497,499,501,503,505,507,
+            509,511,513,515,517,519,521,523,525,527,
+            529,531,533,535,537,539,541,543,545,484,
+            485,486,487,488,489,490,491,492,493,615,
+            619,630,605,617,612,618,606,607,608,609,
+            628,326,613,614,616,297,621,622,623,624,
+            610,625,626,601,602,611,629,603,604,627,
+            620,94,494,496,498,500,502,504,506,508,
+            510,512,514,516,518,520,522,524,526,528,
+            530,532,534,536,538,540,542,544,495,497,
+            499,501,503,505,507,509,511,513,515,517,
+            519,521,523,525,527,529,531,533,535,537,
+            539,541,543,545,484,485,486,487,488,489,
+            490,491,492,493,615,619,630,605,617,612,
+            618,606,607,608,609,628,326,613,614,616,
+            297,621,622,623,624,610,625,626,601,602,
+            611,629,603,604,627,620,93,494,496,498,
+            500,502,504,506,508,510,512,514,516,518,
+            520,522,524,526,528,530,532,534,536,538,
+            540,542,544,495,497,499,501,503,505,507,
+            509,511,513,515,517,519,521,523,525,527,
+            529,531,533,535,537,539,541,543,545,484,
+            485,486,487,488,489,490,491,492,493,615,
+            619,630,605,617,612,618,606,607,608,609,
+            628,483,613,614,616,297,621,622,623,624,
+            610,625,626,601,602,611,629,603,604,627,
+            620,107,494,496,498,500,502,504,506,508,
+            510,512,514,516,518,520,522,524,526,528,
+            530,532,534,536,538,540,542,544,495,497,
+            499,501,503,505,507,509,511,513,515,517,
+            519,521,523,525,527,529,531,533,535,537,
+            539,541,543,545,484,485,486,487,488,489,
+            490,491,492,493,483,494,496,498,500,502,
+            504,506,508,510,512,514,516,518,520,522,
+            524,526,528,530,532,534,536,538,540,542,
+            544,495,497,499,501,503,505,507,509,511,
+            513,515,517,519,521,523,525,527,529,531,
+            533,535,537,539,541,543,545,483,483,91,
+            105,483,483,483,483,483,483,483,483,483,
+            483,483,483,483,483,483,483,483,483,483,
+            483,483,483,483,483,483,483,483,483,483,
+            483,483,483,483,483,483,483,483,483,483,
+            483,483,483,483,483,483,483,483,483,483,
+            483,483,483,483,483,483,483,483,483,483,
+            483,483,373,220,483,483,483,483,483,483,
+            483,483,483,483,326,483,483,483,483,483,
+            483,483,483,483,483,483,483,483,483,483,
+            483,483,483,482,483,483,587
+        };
+    };
+    public final static char termAction[] = TermAction.termAction;
+    public final int termAction(int index) { return termAction[index]; }
+    public final int asb(int index) { return 0; }
+    public final int asr(int index) { return 0; }
+    public final int nasb(int index) { return 0; }
+    public final int nasr(int index) { return 0; }
+    public final int terminalIndex(int index) { return 0; }
+    public final int nonterminalIndex(int index) { return 0; }
+    public final int scopePrefix(int index) { return 0;}
+    public final int scopeSuffix(int index) { return 0;}
+    public final int scopeLhs(int index) { return 0;}
+    public final int scopeLa(int index) { return 0;}
+    public final int scopeStateSet(int index) { return 0;}
+    public final int scopeRhs(int index) { return 0;}
+    public final int scopeState(int index) { return 0;}
+    public final int inSymb(int index) { return 0;}
+    public final String name(int index) { return null; }
+    public final int originalState(int state) { return 0; }
+    public final int asi(int state) { return 0; }
+    public final int nasi(int state) { return 0; }
+    public final int inSymbol(int state) { return 0; }
+
+    /**
+     * assert(! goto_default);
+     */
+    public final int ntAction(int state, int sym) {
+        return baseAction[state + sym];
+    }
+
+    /**
+     * assert(! shift_default);
+     */
+    public final int tAction(int state, int sym) {
+        int i = baseAction[state],
+            k = i + sym;
+        return termAction[termCheck[k] == sym ? k : i];
+    }
+    public final int lookAhead(int la_state, int sym) {
+        int k = la_state + sym;
+        return termAction[termCheck[k] == sym ? k : la_state];
+    }
+}
Index: src/org/eclipse/imp/preferences/PreferenceValueParser.java
===================================================================
--- src/org/eclipse/imp/preferences/PreferenceValueParser.java	(revision 0)
+++ src/org/eclipse/imp/preferences/PreferenceValueParser.java	(revision 0)
@@ -0,0 +1,5082 @@
+
+////////////////////////////////////////////////////////////////////////////////
+// Copyright (c) 2007 IBM Corporation.
+// All rights reserved. This program and the accompanying materials
+// are made available under the terms of the Eclipse Public License v1.0
+// which accompanies this distribution, and is available at
+// http://www.eclipse.org/legal/epl-v10.html
+//
+//Author: Robert Fuhrer (rfuhrer@watson.ibm.com)
+////////////////////////////////////////////////////////////////////////////////
+
+package org.eclipse.imp.preferences;
+
+import org.eclipse.imp.parser.IParser;
+    import java.util.ArrayList;
+    import java.util.List;
+    import java.util.Map;
+    import java.util.HashMap;
+    import java.util.Set;
+    import lpg.runtime.*;
+ 
+public class PreferenceValueParser implements PreferenceValueParsersym, RuleAction {
+    static class MyLexStream extends LpgLexStream {
+        public void initialize(char [] content) {
+            super.initialize(content, "");
+        }
+
+        public final static int tokenKind[] = {
+            Char_CtlCharNotWS,    // 000    0x00
+            Char_CtlCharNotWS,    // 001    0x01
+            Char_CtlCharNotWS,    // 002    0x02
+            Char_CtlCharNotWS,    // 003    0x03
+            Char_CtlCharNotWS,    // 004    0x04
+            Char_CtlCharNotWS,    // 005    0x05
+            Char_CtlCharNotWS,    // 006    0x06
+            Char_CtlCharNotWS,    // 007    0x07
+            Char_CtlCharNotWS,    // 008    0x08
+            Char_HT,              // 009    0x09
+            Char_LF,              // 010    0x0A
+            Char_CtlCharNotWS,    // 011    0x0B
+            Char_FF,              // 012    0x0C
+            Char_CR,              // 013    0x0D
+            Char_CtlCharNotWS,    // 014    0x0E
+            Char_CtlCharNotWS,    // 015    0x0F
+            Char_CtlCharNotWS,    // 016    0x10
+            Char_CtlCharNotWS,    // 017    0x11
+            Char_CtlCharNotWS,    // 018    0x12
+            Char_CtlCharNotWS,    // 019    0x13
+            Char_CtlCharNotWS,    // 020    0x14
+            Char_CtlCharNotWS,    // 021    0x15
+            Char_CtlCharNotWS,    // 022    0x16
+            Char_CtlCharNotWS,    // 023    0x17
+            Char_CtlCharNotWS,    // 024    0x18
+            Char_CtlCharNotWS,    // 025    0x19
+            Char_CtlCharNotWS,    // 026    0x1A
+            Char_CtlCharNotWS,    // 027    0x1B
+            Char_CtlCharNotWS,    // 028    0x1C
+            Char_CtlCharNotWS,    // 029    0x1D
+            Char_CtlCharNotWS,    // 030    0x1E
+            Char_CtlCharNotWS,    // 031    0x1F
+            Char_Space,           // 032    0x20
+            Char_Exclamation,     // 033    0x21
+            Char_DoubleQuote,     // 034    0x22
+            Char_Sharp,           // 035    0x23
+            Char_DollarSign,      // 036    0x24
+            Char_Percent,         // 037    0x25
+            Char_Ampersand,       // 038    0x26
+            Char_SingleQuote,     // 039    0x27
+            Char_LeftParen,       // 040    0x28
+            Char_RightParen,      // 041    0x29
+            Char_Star,            // 042    0x2A
+            Char_Plus,            // 043    0x2B
+            Char_Comma,           // 044    0x2C
+            Char_Minus,           // 045    0x2D
+            Char_Dot,             // 046    0x2E
+            Char_Slash,           // 047    0x2F
+            Char_0,               // 048    0x30
+            Char_1,               // 049    0x31
+            Char_2,               // 050    0x32
+            Char_3,               // 051    0x33
+            Char_4,               // 052    0x34
+            Char_5,               // 053    0x35
+            Char_6,               // 054    0x36
+            Char_7,               // 055    0x37
+            Char_8,               // 056    0x38
+            Char_9,               // 057    0x39
+            Char_Colon,           // 058    0x3A
+            Char_SemiColon,       // 059    0x3B
+            Char_LessThan,        // 060    0x3C
+            Char_Equal,           // 061    0x3D
+            Char_GreaterThan,     // 062    0x3E
+            Char_QuestionMark,    // 063    0x3F
+            Char_AtSign,          // 064    0x40
+            Char_A,               // 065    0x41
+            Char_B,               // 066    0x42
+            Char_C,               // 067    0x43
+            Char_D,               // 068    0x44
+            Char_E,               // 069    0x45
+            Char_F,               // 070    0x46
+            Char_G,               // 071    0x47
+            Char_H,               // 072    0x48
+            Char_I,               // 073    0x49
+            Char_J,               // 074    0x4A
+            Char_K,               // 075    0x4B
+            Char_L,               // 076    0x4C
+            Char_M,               // 077    0x4D
+            Char_N,               // 078    0x4E
+            Char_O,               // 079    0x4F
+            Char_P,               // 080    0x50
+            Char_Q,               // 081    0x51
+            Char_R,               // 082    0x52
+            Char_S,               // 083    0x53
+            Char_T,               // 084    0x54
+            Char_U,               // 085    0x55
+            Char_V,               // 086    0x56
+            Char_W,               // 087    0x57
+            Char_X,               // 088    0x58
+            Char_Y,               // 089    0x59
+            Char_Z,               // 090    0x5A
+            Char_LeftBracket,     // 091    0x5B
+            Char_BackSlash,       // 092    0x5C
+            Char_RightBracket,    // 093    0x5D
+            Char_Caret,           // 094    0x5E
+            Char__,               // 095    0x5F
+            Char_BackQuote,       // 096    0x60
+            Char_a,               // 097    0x61
+            Char_b,               // 098    0x62
+            Char_c,               // 099    0x63
+            Char_d,               // 100    0x64
+            Char_e,               // 101    0x65
+            Char_f,               // 102    0x66
+            Char_g,               // 103    0x67
+            Char_h,               // 104    0x68
+            Char_i,               // 105    0x69
+            Char_j,               // 106    0x6A
+            Char_k,               // 107    0x6B
+            Char_l,               // 108    0x6C
+            Char_m,               // 109    0x6D
+            Char_n,               // 110    0x6E
+            Char_o,               // 111    0x6F
+            Char_p,               // 112    0x70
+            Char_q,               // 113    0x71
+            Char_r,               // 114    0x72
+            Char_s,               // 115    0x73
+            Char_t,               // 116    0x74
+            Char_u,               // 117    0x75
+            Char_v,               // 118    0x76
+            Char_w,               // 119    0x77
+            Char_x,               // 120    0x78
+            Char_y,               // 121    0x79
+            Char_z,               // 122    0x7A
+            Char_LeftBrace,       // 123    0x7B
+            Char_VerticalBar,     // 124    0x7C
+            Char_RightBrace,      // 125    0x7D
+            Char_Tilde,           // 126    0x7E
+
+            Char_AfterASCII,      // for all chars in range 128..65534
+            Char_EOF              // for '\uffff' or 65535 
+        };
+                
+        public final int getKind(int i) { // Classify character at ith location
+            char c = (i >= getStreamLength() ? '\uffff' : getCharValue(i));
+            return (c < 128 // ASCII Character
+                      ? tokenKind[c]
+                      : c == '\uffff'
+                           ? PreferenceValueParsersym.Char_EOF
+                           : PreferenceValueParsersym.Char_AfterASCII);
+        }
+        public String[] orderedExportedSymbols() { return PreferenceValueParsersym.orderedTerminalSymbols; }
+    };
+
+    private MyLexStream lexStream = new MyLexStream();
+
+    private static ParseTable prs = new PreferenceValueParserprs();
+    private DeterministicParser dtParser;
+
+    private void setResult(Object object) { dtParser.setSym1(object); }
+    public DeterministicParser getParser() { return dtParser; }
+
+    public Object getRhsSym(int i) { return dtParser.getSym(i); }
+
+    public int getRhsTokenIndex(int i) { return dtParser.getToken(i); }
+    public int getRhsFirstTokenIndex(int i) { return dtParser.getFirstToken(i); }
+    public int getRhsLastTokenIndex(int i) { return dtParser.getLastToken(i); }
+
+public IToken getLeftIToken() { return new MyToken(dtParser.getFirstToken(), lexStream); }
+public IToken getRightIToken() { return new MyToken(dtParser.getLastToken(), lexStream); }
+
+public IToken getRhsIToken(int idx) { return new MyToken(dtParser.getToken(idx), lexStream); }
+
+    public int getLeftSpan() { return dtParser.getFirstToken(); }
+    public int getRightSpan() { return dtParser.getLastToken(); }
+
+    public int getEOFTokenKind() { return PreferenceValueParserprs.EOFT_SYMBOL; }
+    public LpgLexStream getLexStream() { return lexStream; }
+
+    private String errorMsg= "";
+
+    public String getErrorMessage() { return errorMsg; }
+
+    public ASTNode parser(String input) {
+        try {
+            lexStream.initialize(input.toCharArray());
+            dtParser = new DeterministicParser(lexStream, prs, this);
+        } catch (NotDeterministicParseTableException e) {
+            System.out.println("****Error: Regenerate PreferenceValueParserprs.java with -NOBACKTRACK option");
+            return null;
+        } catch (BadParseSymFileException e) {
+            System.out.println("****Error: Bad Parser Symbol File -- PreferenceValueParsersym.java. Regenerate PreferenceValueParserprs.java");
+            return null;
+        }
+
+        try {
+            return (ASTNode) dtParser.parse();
+        } catch (BadParseException e) {
+            errorMsg= "unexpected";
+            if (e.error_token < lexStream.getStreamLength())
+                errorMsg += " character '" + lexStream.getCharValue(e.error_token) + "' at offset " + e.error_token;
+            else
+                errorMsg += " end of string";
+        }
+        return null;
+    }
+
+private class MyToken implements IToken {
+    private int offset;
+    private LpgLexStream lexStream;
+    public MyToken(int offset, LpgLexStream ls) {
+        this.offset= offset;
+        this.lexStream= ls;
+    }
+    public int getKind() { return lexStream.getKind(lexStream.getInputChars()[offset]); }
+    public void setKind(int kind) { }
+
+    public int getStartOffset() { return offset; }
+    public void setStartOffset(int startOffset) { }
+
+    public int getEndOffset() { return offset; }
+    public void setEndOffset(int endOffset) { }
+
+    public int getTokenIndex() { return offset; }
+    public void setTokenIndex(int i) { }
+
+    public int getAdjunctIndex() { return -1; }
+    public void setAdjunctIndex(int i) { }
+
+    public IToken[] getPrecedingAdjuncts() { return null; }
+    public IToken[] getFollowingAdjuncts() { return null; }
+
+    public IPrsStream getPrsStream() { return null; }
+    public LpgLexStream getLexStream() { return lexStream; }
+
+    public int getLine() { return lexStream.getLine(offset); }
+    public int getColumn() { return lexStream.getColumn(offset); }
+    public int getEndLine() { return lexStream.getLine(offset); }
+    public int getEndColumn() { return lexStream.getColumn(offset); }
+
+    public String getValue(char[] inputChars) { return toString(); }
+
+    public String toString() {
+        return new String(new char[] { lexStream.getInputChars()[offset] });
+    }
+}
+    static public abstract class ASTNode implements IAst
+    {
+        public IAst getNextAst() { return null; }
+        protected IToken leftIToken,
+                         rightIToken;
+        protected IAst parent = null;
+        protected void setParent(IAst parent) { this.parent = parent; }
+        public IAst getParent() { return parent; }
+
+        public IToken getLeftIToken() { return leftIToken; }
+        public IToken getRightIToken() { return rightIToken; }
+        public IToken[] getPrecedingAdjuncts() { return leftIToken.getPrecedingAdjuncts(); }
+        public IToken[] getFollowingAdjuncts() { return rightIToken.getFollowingAdjuncts(); }
+
+        public String toString()
+        {
+            return leftIToken.getLexStream().toString(leftIToken.getStartOffset(), rightIToken.getEndOffset());
+        }
+
+        public ASTNode(IToken token) { this.leftIToken = this.rightIToken = token; }
+        public ASTNode(IToken leftIToken, IToken rightIToken)
+        {
+            this.leftIToken = leftIToken;
+            this.rightIToken = rightIToken;
+        }
+
+        void initialize() {}
+
+        /**
+         * A list of all children of this node, excluding the null ones.
+         */
+        public java.util.ArrayList getChildren()
+        {
+            java.util.ArrayList list = getAllChildren();
+            int k = -1;
+            for (int i = 0; i < list.size(); i++)
+            {
+                Object element = list.get(i);
+                if (element != null)
+                {
+                    if (++k != i)
+                        list.set(k, element);
+                }
+            }
+            for (int i = list.size() - 1; i > k; i--) // remove extraneous elements
+                list.remove(i);
+            return list;
+        }
+
+        /**
+         * A list of all children of this node, including the null ones.
+         */
+        public abstract java.util.ArrayList getAllChildren();
+
+        public boolean equals(Object o)
+        {
+            if (o == this) return true;
+            if (! (o instanceof ASTNode)) return false;
+            ASTNode other = (ASTNode) o;
+            return getLeftIToken().getLexStream() == other.getLeftIToken().getLexStream() &&
+                   getLeftIToken().getTokenIndex() == other.getLeftIToken().getTokenIndex() &&
+                   getRightIToken().getLexStream() == other.getRightIToken().getLexStream() &&
+                   getRightIToken().getTokenIndex() == other.getRightIToken().getTokenIndex();
+        }
+
+        public int hashCode()
+        {
+            int hash = 7;
+            if (getLeftIToken().getLexStream() != null) hash = hash * 31 + getLeftIToken().getLexStream().hashCode();
+            hash = hash * 31 + getLeftIToken().getTokenIndex();
+            if (getRightIToken().getLexStream() != null) hash = hash * 31 + getRightIToken().getLexStream().hashCode();
+            hash = hash * 31 + getRightIToken().getTokenIndex();
+            return hash;
+        }
+        public abstract void accept(IAstVisitor v);
+    }
+
+    static public abstract class AbstractASTNodeList extends ASTNode
+    {
+        private boolean leftRecursive;
+        private java.util.ArrayList list;
+        public int size() { return list.size(); }
+        public ASTNode getElementAt(int i) { return (ASTNode) list.get(leftRecursive ? i : list.size() - 1 - i); }
+        public java.util.ArrayList getArrayList()
+        {
+            if (! leftRecursive) // reverse the list 
+            {
+                for (int i = 0, n = list.size() - 1; i < n; i++, n--)
+                {
+                    Object ith = list.get(i),
+                           nth = list.get(n);
+                    list.set(i, nth);
+                    list.set(n, ith);
+                }
+                leftRecursive = true;
+            }
+            return list;
+        }
+        public void add(ASTNode element)
+        {
+            list.add(element);
+            if (leftRecursive)
+                 rightIToken = element.getRightIToken();
+            else leftIToken = element.getLeftIToken();
+        }
+
+        public AbstractASTNodeList(IToken leftIToken, IToken rightIToken, boolean leftRecursive)
+        {
+            super(leftIToken, rightIToken);
+            this.leftRecursive = leftRecursive;
+            list = new java.util.ArrayList();
+        }
+
+        public AbstractASTNodeList(ASTNode element, boolean leftRecursive)
+        {
+            this(element.getLeftIToken(), element.getRightIToken(), leftRecursive);
+            list.add(element);
+        }
+
+        /**
+         * Make a copy of the list and return it. Note that we obtain the local list by
+         * invoking getArrayList so as to make sure that the list we return is in proper order.
+         */
+        public java.util.ArrayList getAllChildren()
+        {
+            return (java.util.ArrayList) getArrayList().clone();
+        }
+
+    }
+
+    static public class ASTNodeToken extends ASTNode implements IASTNodeToken
+    {
+        public ASTNodeToken(IToken token) { super(token); }
+        public IToken getIToken() { return leftIToken; }
+        public String toString() { return leftIToken.toString(); }
+
+        /**
+         * A token class has no children. So, we return the empty list.
+         */
+        public java.util.ArrayList getAllChildren() { return new java.util.ArrayList(); }
+
+        public boolean equals(Object o)
+        {
+            if (o == this) return true;
+            if (! (o instanceof ASTNodeToken)) return false;
+            ASTNodeToken other = (ASTNodeToken) o;
+            return getIToken().getLexStream() == other.getIToken().getLexStream() &&
+                   getIToken().getTokenIndex() == other.getIToken().getTokenIndex();
+        }
+
+        public int hashCode()
+        {
+            int hash = 7;
+            if (getIToken().getLexStream() != null) hash = hash * 31 + getIToken().getLexStream().hashCode();
+            hash = hash * 31 + getIToken().getTokenIndex();
+            return hash;
+        }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *<li>specialNoDollarRBrace0
+     *<li>specialNoDollarRBrace1
+     *<li>specialNoDollarRBrace2
+     *<li>specialNoDollarRBrace3
+     *<li>specialNoDollarRBrace4
+     *<li>specialNoDollarRBrace5
+     *<li>specialNoDollarRBrace6
+     *<li>specialNoDollarRBrace7
+     *<li>specialNoDollarRBrace8
+     *<li>specialNoDollarRBrace9
+     *<li>specialNoDollarRBrace10
+     *<li>specialNoDollarRBrace11
+     *<li>specialNoDollarRBrace12
+     *<li>specialNoDollarRBrace13
+     *<li>specialNoDollarRBrace14
+     *<li>specialNoDollarRBrace15
+     *<li>specialNoDollarRBrace16
+     *<li>specialNoDollarRBrace17
+     *<li>specialNoDollarRBrace18
+     *<li>specialNoDollarRBrace19
+     *<li>specialNoDollarRBrace20
+     *<li>specialNoDollarRBrace21
+     *<li>specialNoDollarRBrace22
+     *<li>specialNoDollarRBrace23
+     *<li>specialNoDollarRBrace24
+     *<li>specialNoDollarRBrace25
+     *<li>specialNoDollarRBrace26
+     *<li>specialNoDollarRBrace27
+     *<li>specialNoDollarRBrace28
+     *<li>specialNoDollarRBrace29
+     *<li>special0
+     *<li>special1
+     *<li>special2
+     *<li>special3
+     *<li>special4
+     *<li>special5
+     *<li>special6
+     *<li>special7
+     *<li>special8
+     *<li>special9
+     *<li>special10
+     *<li>special11
+     *<li>special12
+     *<li>special13
+     *<li>special14
+     *<li>special15
+     *<li>special16
+     *<li>special17
+     *<li>special18
+     *<li>special19
+     *<li>special20
+     *<li>special21
+     *<li>special22
+     *<li>special23
+     *<li>special24
+     *<li>special25
+     *<li>special26
+     *<li>special27
+     *<li>special28
+     *<li>special29
+     *<li>special30
+     *<li>special31
+     *<li>special32
+     *</ul>
+     *</b>
+     */
+    public interface IASTNodeToken
+    {
+        public IToken getLeftIToken();
+        public IToken getRightIToken();
+
+        void accept(IAstVisitor v);
+    }
+
+    /**
+     * is implemented by:
+     *<b>
+     *<ul>
+     *<li>simpleStringPrefixed
+     *<li>valStringNoSubst
+     *<li>substPrefixed
+     *<li>substitutionList
+     *<li>escapedChar
+     *<li>specialNoDollarRBrace0
+     *<li>specialNoDollarRBrace1
+     *<li>specialNoDollarRBrace2
+     *<li>specialNoDollarRBrace3
+     *<li>specialNoDollarRBrace4
+     *<li>specialNoDollarRBrace5
+     *<li>specialNoDollarRBrace6
+     *<li>specialNoDollarRBrace7
+     *<li>specialNoDollarRBrace8
+     *<li>specialNoDollarRBrace9
+     *<li>specialNoDollarRBrace10
+     *<li>specialNoDollarRBrace11
+     *<li>specialNoDollarRBrace12
+     *<li>specialNoDollarRBrace13
+     *<li>specialNoDollarRBrace14
+     *<li>specialNoDollarRBrace15
+     *<li>specialNoDollarRBrace16
+     *<li>specialNoDollarRBrace17
+     *<li>specialNoDollarRBrace18
+     *<li>specialNoDollarRBrace19
+     *<li>specialNoDollarRBrace20
+     *<li>specialNoDollarRBrace21
+     *<li>specialNoDollarRBrace22
+     *<li>specialNoDollarRBrace23
+     *<li>specialNoDollarRBrace24
+     *<li>specialNoDollarRBrace25
+     *<li>specialNoDollarRBrace26
+     *<li>specialNoDollarRBrace27
+     *<li>specialNoDollarRBrace28
+     *<li>specialNoDollarRBrace29
+     *</ul>
+     *</b>
+     */
+    public interface Ivalue
+    {
+        public IToken getLeftIToken();
+        public IToken getRightIToken();
+
+        void accept(IAstVisitor v);
+    }
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface Idigit extends IASTNodeToken, InonSubstStart, IescapableChar {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IaA extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IbB extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IcC extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IdD extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IeE extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IfF extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IgG extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IhH extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IiI extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IjJ extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IkK extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IlL extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface ImM extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface InN extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IoO extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IpP extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IqQ extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IrR extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IsS extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface ItT extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IuU extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IvV extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IwW extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IxX extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IyY extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IzZ extends IASTNodeToken, Iletter {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface Iletter extends IidentChars, InonSubstStart, IescapableChar {}
+
+    /**
+     * is implemented by:
+     *<b>
+     *<ul>
+     *<li>simpleStringPrefixed
+     *<li>valStringNoSubst
+     *<li>escapedChar
+     *<li>specialNoDollarRBrace0
+     *<li>specialNoDollarRBrace1
+     *<li>specialNoDollarRBrace2
+     *<li>specialNoDollarRBrace3
+     *<li>specialNoDollarRBrace4
+     *<li>specialNoDollarRBrace5
+     *<li>specialNoDollarRBrace6
+     *<li>specialNoDollarRBrace7
+     *<li>specialNoDollarRBrace8
+     *<li>specialNoDollarRBrace9
+     *<li>specialNoDollarRBrace10
+     *<li>specialNoDollarRBrace11
+     *<li>specialNoDollarRBrace12
+     *<li>specialNoDollarRBrace13
+     *<li>specialNoDollarRBrace14
+     *<li>specialNoDollarRBrace15
+     *<li>specialNoDollarRBrace16
+     *<li>specialNoDollarRBrace17
+     *<li>specialNoDollarRBrace18
+     *<li>specialNoDollarRBrace19
+     *<li>specialNoDollarRBrace20
+     *<li>specialNoDollarRBrace21
+     *<li>specialNoDollarRBrace22
+     *<li>specialNoDollarRBrace23
+     *<li>specialNoDollarRBrace24
+     *<li>specialNoDollarRBrace25
+     *<li>specialNoDollarRBrace26
+     *<li>specialNoDollarRBrace27
+     *<li>specialNoDollarRBrace28
+     *<li>specialNoDollarRBrace29
+     *</ul>
+     *</b>
+     */
+    public interface IsimpleStringPrefixed extends Ivalue {}
+
+    /**
+     * is implemented by:
+     *<b>
+     *<ul>
+     *<li>substPrefixed
+     *<li>substitutionList
+     *</ul>
+     *</b>
+     */
+    public interface IsubstPrefixed extends Ivalue {}
+
+    /**
+     * is implemented by:
+     *<b>
+     *<ul>
+     *<li>valStringNoSubst
+     *<li>escapedChar
+     *<li>specialNoDollarRBrace0
+     *<li>specialNoDollarRBrace1
+     *<li>specialNoDollarRBrace2
+     *<li>specialNoDollarRBrace3
+     *<li>specialNoDollarRBrace4
+     *<li>specialNoDollarRBrace5
+     *<li>specialNoDollarRBrace6
+     *<li>specialNoDollarRBrace7
+     *<li>specialNoDollarRBrace8
+     *<li>specialNoDollarRBrace9
+     *<li>specialNoDollarRBrace10
+     *<li>specialNoDollarRBrace11
+     *<li>specialNoDollarRBrace12
+     *<li>specialNoDollarRBrace13
+     *<li>specialNoDollarRBrace14
+     *<li>specialNoDollarRBrace15
+     *<li>specialNoDollarRBrace16
+     *<li>specialNoDollarRBrace17
+     *<li>specialNoDollarRBrace18
+     *<li>specialNoDollarRBrace19
+     *<li>specialNoDollarRBrace20
+     *<li>specialNoDollarRBrace21
+     *<li>specialNoDollarRBrace22
+     *<li>specialNoDollarRBrace23
+     *<li>specialNoDollarRBrace24
+     *<li>specialNoDollarRBrace25
+     *<li>specialNoDollarRBrace26
+     *<li>specialNoDollarRBrace27
+     *<li>specialNoDollarRBrace28
+     *<li>specialNoDollarRBrace29
+     *</ul>
+     *</b>
+     */
+    public interface IvalStringNoSubst extends IsimpleStringPrefixed {}
+
+    /**
+     * is implemented by:
+     *<b>
+     *<ul>
+     *<li>escapedChar
+     *<li>specialNoDollarRBrace0
+     *<li>specialNoDollarRBrace1
+     *<li>specialNoDollarRBrace2
+     *<li>specialNoDollarRBrace3
+     *<li>specialNoDollarRBrace4
+     *<li>specialNoDollarRBrace5
+     *<li>specialNoDollarRBrace6
+     *<li>specialNoDollarRBrace7
+     *<li>specialNoDollarRBrace8
+     *<li>specialNoDollarRBrace9
+     *<li>specialNoDollarRBrace10
+     *<li>specialNoDollarRBrace11
+     *<li>specialNoDollarRBrace12
+     *<li>specialNoDollarRBrace13
+     *<li>specialNoDollarRBrace14
+     *<li>specialNoDollarRBrace15
+     *<li>specialNoDollarRBrace16
+     *<li>specialNoDollarRBrace17
+     *<li>specialNoDollarRBrace18
+     *<li>specialNoDollarRBrace19
+     *<li>specialNoDollarRBrace20
+     *<li>specialNoDollarRBrace21
+     *<li>specialNoDollarRBrace22
+     *<li>specialNoDollarRBrace23
+     *<li>specialNoDollarRBrace24
+     *<li>specialNoDollarRBrace25
+     *<li>specialNoDollarRBrace26
+     *<li>specialNoDollarRBrace27
+     *<li>specialNoDollarRBrace28
+     *<li>specialNoDollarRBrace29
+     *</ul>
+     *</b>
+     */
+    public interface IvalueStringNoSubst extends IvalStringNoSubst {}
+
+    /**
+     * is implemented by <b>substitutionList</b>
+     */
+    public interface IsubstitutionList extends IsubstPrefixed {}
+
+    /**
+     * is implemented by <b>substitution</b>
+     */
+    public interface Isubstitution
+    {
+        public IToken getLeftIToken();
+        public IToken getRightIToken();
+
+        void accept(IAstVisitor v);
+    }
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *<li>specialNoDollarRBrace0
+     *<li>specialNoDollarRBrace1
+     *<li>specialNoDollarRBrace2
+     *<li>specialNoDollarRBrace3
+     *<li>specialNoDollarRBrace4
+     *<li>specialNoDollarRBrace5
+     *<li>specialNoDollarRBrace6
+     *<li>specialNoDollarRBrace7
+     *<li>specialNoDollarRBrace8
+     *<li>specialNoDollarRBrace9
+     *<li>specialNoDollarRBrace10
+     *<li>specialNoDollarRBrace11
+     *<li>specialNoDollarRBrace12
+     *<li>specialNoDollarRBrace13
+     *<li>specialNoDollarRBrace14
+     *<li>specialNoDollarRBrace15
+     *<li>specialNoDollarRBrace16
+     *<li>specialNoDollarRBrace17
+     *<li>specialNoDollarRBrace18
+     *<li>specialNoDollarRBrace19
+     *<li>specialNoDollarRBrace20
+     *<li>specialNoDollarRBrace21
+     *<li>specialNoDollarRBrace22
+     *<li>specialNoDollarRBrace23
+     *<li>specialNoDollarRBrace24
+     *<li>specialNoDollarRBrace25
+     *<li>specialNoDollarRBrace26
+     *<li>specialNoDollarRBrace27
+     *<li>specialNoDollarRBrace28
+     *<li>specialNoDollarRBrace29
+     *</ul>
+     *</b>
+     */
+    public interface InonSubstStart extends IvalueStringNoSubst {}
+
+    /**
+     * is implemented by <b>escapedChar</b>
+     */
+    public interface IescapedChar extends IvalueStringNoSubst {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *<li>specialNoDollarRBrace0
+     *<li>specialNoDollarRBrace1
+     *<li>specialNoDollarRBrace2
+     *<li>specialNoDollarRBrace3
+     *<li>specialNoDollarRBrace4
+     *<li>specialNoDollarRBrace5
+     *<li>specialNoDollarRBrace6
+     *<li>specialNoDollarRBrace7
+     *<li>specialNoDollarRBrace8
+     *<li>specialNoDollarRBrace9
+     *<li>specialNoDollarRBrace10
+     *<li>specialNoDollarRBrace11
+     *<li>specialNoDollarRBrace12
+     *<li>specialNoDollarRBrace13
+     *<li>specialNoDollarRBrace14
+     *<li>specialNoDollarRBrace15
+     *<li>specialNoDollarRBrace16
+     *<li>specialNoDollarRBrace17
+     *<li>specialNoDollarRBrace18
+     *<li>specialNoDollarRBrace19
+     *<li>specialNoDollarRBrace20
+     *<li>specialNoDollarRBrace21
+     *<li>specialNoDollarRBrace22
+     *<li>specialNoDollarRBrace23
+     *<li>specialNoDollarRBrace24
+     *<li>specialNoDollarRBrace25
+     *<li>specialNoDollarRBrace26
+     *<li>specialNoDollarRBrace27
+     *<li>specialNoDollarRBrace28
+     *<li>specialNoDollarRBrace29
+     *</ul>
+     *</b>
+     */
+    public interface IspecialNoDollarRBrace extends InonSubstStart, IASTNodeToken {}
+
+    /**
+     * is implemented by <b>ident</b>
+     */
+    public interface Iident
+    {
+        public IToken getLeftIToken();
+        public IToken getRightIToken();
+
+        void accept(IAstVisitor v);
+    }
+
+    /**
+     * is implemented by <b>optParameter</b>
+     */
+    public interface IoptParameter
+    {
+        public IToken getLeftIToken();
+        public IToken getRightIToken();
+
+        void accept(IAstVisitor v);
+    }
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *</ul>
+     *</b>
+     */
+    public interface IidentChars extends Iident {}
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *<li>special0
+     *<li>special1
+     *<li>special2
+     *<li>special3
+     *<li>special4
+     *<li>special5
+     *<li>special6
+     *<li>special7
+     *<li>special8
+     *<li>special9
+     *<li>special10
+     *<li>special11
+     *<li>special12
+     *<li>special13
+     *<li>special14
+     *<li>special15
+     *<li>special16
+     *<li>special17
+     *<li>special18
+     *<li>special19
+     *<li>special20
+     *<li>special21
+     *<li>special22
+     *<li>special23
+     *<li>special24
+     *<li>special25
+     *<li>special26
+     *<li>special27
+     *<li>special28
+     *<li>special29
+     *<li>special30
+     *<li>special31
+     *<li>special32
+     *</ul>
+     *</b>
+     */
+    public interface IescapableChar
+    {
+        public IToken getLeftIToken();
+        public IToken getRightIToken();
+
+        void accept(IAstVisitor v);
+    }
+
+    /**
+     * is always implemented by <b>ASTNodeToken</b>. It is also implemented by:
+     *<b>
+     *<ul>
+     *<li>special0
+     *<li>special1
+     *<li>special2
+     *<li>special3
+     *<li>special4
+     *<li>special5
+     *<li>special6
+     *<li>special7
+     *<li>special8
+     *<li>special9
+     *<li>special10
+     *<li>special11
+     *<li>special12
+     *<li>special13
+     *<li>special14
+     *<li>special15
+     *<li>special16
+     *<li>special17
+     *<li>special18
+     *<li>special19
+     *<li>special20
+     *<li>special21
+     *<li>special22
+     *<li>special23
+     *<li>special24
+     *<li>special25
+     *<li>special26
+     *<li>special27
+     *<li>special28
+     *<li>special29
+     *<li>special30
+     *<li>special31
+     *<li>special32
+     *</ul>
+     *</b>
+     */
+    public interface Ispecial extends IescapableChar, IASTNodeToken {}
+
+    /**
+     *<b>
+     *<li>Rule 91:  simpleStringPrefixed ::= valStringNoSubst
+     *<li>Rule 92:  simpleStringPrefixed ::= valStringNoSubst substPrefixed
+     *</b>
+     */
+    static public class simpleStringPrefixed extends ASTNode implements IsimpleStringPrefixed
+    {
+        private IvalStringNoSubst _valStringNoSubst;
+        private IsubstPrefixed _substPrefixed;
+
+        public IvalStringNoSubst getvalStringNoSubst() { return _valStringNoSubst; }
+        /**
+         * The value returned by <b>getsubstPrefixed</b> may be <b>null</b>
+         */
+        public IsubstPrefixed getsubstPrefixed() { return _substPrefixed; }
+
+        public simpleStringPrefixed(IToken leftIToken, IToken rightIToken,
+                                    IvalStringNoSubst _valStringNoSubst,
+                                    IsubstPrefixed _substPrefixed)
+        {
+            super(leftIToken, rightIToken);
+
+            this._valStringNoSubst = _valStringNoSubst;
+            ((ASTNode) _valStringNoSubst).setParent(this);
+            this._substPrefixed = _substPrefixed;
+            if (_substPrefixed != null) ((ASTNode) _substPrefixed).setParent(this);
+            initialize();
+        }
+
+        /**
+         * A list of all children of this node, including the null ones.
+         */
+        public java.util.ArrayList getAllChildren()
+        {
+            java.util.ArrayList list = new java.util.ArrayList();
+            list.add(_valStringNoSubst);
+            list.add(_substPrefixed);
+            return list;
+        }
+
+        public boolean equals(Object o)
+        {
+            if (o == this) return true;
+            if (! (o instanceof simpleStringPrefixed)) return false;
+            if (! super.equals(o)) return false;
+            simpleStringPrefixed other = (simpleStringPrefixed) o;
+            if (! _valStringNoSubst.equals(other._valStringNoSubst)) return false;
+            if (_substPrefixed == null)
+                if (other._substPrefixed != null) return false;
+                else; // continue
+            else if (! _substPrefixed.equals(other._substPrefixed)) return false;
+            return true;
+        }
+
+        public int hashCode()
+        {
+            int hash = super.hashCode();
+            hash = hash * 31 + (_valStringNoSubst.hashCode());
+            hash = hash * 31 + (_substPrefixed == null ? 0 : _substPrefixed.hashCode());
+            return hash;
+        }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            boolean checkChildren = v.visit(this);
+            if (checkChildren)
+            {
+                _valStringNoSubst.accept(v);
+                if (_substPrefixed != null) _substPrefixed.accept(v);
+            }
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 93:  valStringNoSubst ::= valueStringNoSubst$
+     *</b>
+     */
+    static public class valStringNoSubst extends ASTNode implements IvalStringNoSubst
+    {
+        public valStringNoSubst(IToken leftIToken, IToken rightIToken)
+        {
+            super(leftIToken, rightIToken);
+
+            initialize();
+        }
+
+        /**
+         * A list of all children of this node, including the null ones.
+         */
+        public java.util.ArrayList getAllChildren()
+        {
+            java.util.ArrayList list = new java.util.ArrayList();
+            return list;
+        }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<em>
+     *<li>Rule 94:  substPrefixed ::= substitutionList
+     *</em>
+     *<p>
+     *<b>
+     *<li>Rule 95:  substPrefixed ::= substitutionList simpleStringPrefixed
+     *</b>
+     */
+    static public class substPrefixed extends ASTNode implements IsubstPrefixed
+    {
+        private substitutionList _substitutionList;
+        private IsimpleStringPrefixed _simpleStringPrefixed;
+
+        public substitutionList getsubstitutionList() { return _substitutionList; }
+        public IsimpleStringPrefixed getsimpleStringPrefixed() { return _simpleStringPrefixed; }
+
+        public substPrefixed(IToken leftIToken, IToken rightIToken,
+                             substitutionList _substitutionList,
+                             IsimpleStringPrefixed _simpleStringPrefixed)
+        {
+            super(leftIToken, rightIToken);
+
+            this._substitutionList = _substitutionList;
+            ((ASTNode) _substitutionList).setParent(this);
+            this._simpleStringPrefixed = _simpleStringPrefixed;
+            ((ASTNode) _simpleStringPrefixed).setParent(this);
+            initialize();
+        }
+
+        /**
+         * A list of all children of this node, including the null ones.
+         */
+        public java.util.ArrayList getAllChildren()
+        {
+            java.util.ArrayList list = new java.util.ArrayList();
+            list.add(_substitutionList);
+            list.add(_simpleStringPrefixed);
+            return list;
+        }
+
+        public boolean equals(Object o)
+        {
+            if (o == this) return true;
+            if (! (o instanceof substPrefixed)) return false;
+            if (! super.equals(o)) return false;
+            substPrefixed other = (substPrefixed) o;
+            if (! _substitutionList.equals(other._substitutionList)) return false;
+            if (! _simpleStringPrefixed.equals(other._simpleStringPrefixed)) return false;
+            return true;
+        }
+
+        public int hashCode()
+        {
+            int hash = super.hashCode();
+            hash = hash * 31 + (_substitutionList.hashCode());
+            hash = hash * 31 + (_simpleStringPrefixed.hashCode());
+            return hash;
+        }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            boolean checkChildren = v.visit(this);
+            if (checkChildren)
+            {
+                _substitutionList.accept(v);
+                _simpleStringPrefixed.accept(v);
+            }
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 96:  substitutionList ::= substitution
+     *<li>Rule 97:  substitutionList ::= substitutionList substitution
+     *</b>
+     */
+    static public class substitutionList extends AbstractASTNodeList implements IsubstitutionList
+    {
+        public substitution getsubstitutionAt(int i) { return (substitution) getElementAt(i); }
+
+        public substitutionList(IToken leftIToken, IToken rightIToken, boolean leftRecursive)
+        {
+            super(leftIToken, rightIToken, leftRecursive);
+        }
+
+        public substitutionList(substitution _substitution, boolean leftRecursive)
+        {
+            super((ASTNode) _substitution, leftRecursive);
+            ((ASTNode) _substitution).setParent(this);
+        }
+
+        public void add(substitution _substitution)
+        {
+            super.add((ASTNode) _substitution);
+            ((ASTNode) _substitution).setParent(this);
+        }
+
+        public boolean equals(Object o)
+        {
+            if (o == this) return true;
+            if (! (o instanceof substitutionList)) return false;
+            if (! super.equals(o)) return false;
+            substitutionList other = (substitutionList    ) o;
+            if (size() != other.size()) return false;
+            for (int i = 0; i < size(); i++)
+            {
+                substitution element = getsubstitutionAt(i);
+                    if (! element.equals(other.getsubstitutionAt(i))) return false;
+            }
+            return true;
+        }
+
+        public int hashCode()
+        {
+            int hash = super.hashCode();
+            for (int i = 0; i < size(); i++)
+                hash = hash * 31 + (getsubstitutionAt(i).hashCode());
+            return hash;
+        }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+        public void enter(Visitor v)
+        {
+            boolean checkChildren = v.visit(this);
+            if (checkChildren)
+            {
+                for (int i = 0; i < size(); i++)
+                {
+                    substitution element = getsubstitutionAt(i);
+                    if (! v.preVisit(element)) continue;
+                    element.enter(v);
+                    v.postVisit(element);
+                }
+            }
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 104:  substitution ::= $$ {$ ident optParameter }$
+     *</b>
+     */
+    static public class substitution extends ASTNode implements Isubstitution
+    {
+        private ident _ident;
+        private optParameter _optParameter;
+
+        public ident getident() { return _ident; }
+        /**
+         * The value returned by <b>getoptParameter</b> may be <b>null</b>
+         */
+        public optParameter getoptParameter() { return _optParameter; }
+
+        public substitution(IToken leftIToken, IToken rightIToken,
+                            ident _ident,
+                            optParameter _optParameter)
+        {
+            super(leftIToken, rightIToken);
+
+            this._ident = _ident;
+            ((ASTNode) _ident).setParent(this);
+            this._optParameter = _optParameter;
+            if (_optParameter != null) ((ASTNode) _optParameter).setParent(this);
+            initialize();
+        }
+
+        /**
+         * A list of all children of this node, including the null ones.
+         */
+        public java.util.ArrayList getAllChildren()
+        {
+            java.util.ArrayList list = new java.util.ArrayList();
+            list.add(_ident);
+            list.add(_optParameter);
+            return list;
+        }
+
+        public boolean equals(Object o)
+        {
+            if (o == this) return true;
+            if (! (o instanceof substitution)) return false;
+            if (! super.equals(o)) return false;
+            substitution other = (substitution) o;
+            if (! _ident.equals(other._ident)) return false;
+            if (_optParameter == null)
+                if (other._optParameter != null) return false;
+                else; // continue
+            else if (! _optParameter.equals(other._optParameter)) return false;
+            return true;
+        }
+
+        public int hashCode()
+        {
+            int hash = super.hashCode();
+            hash = hash * 31 + (_ident.hashCode());
+            hash = hash * 31 + (_optParameter == null ? 0 : _optParameter.hashCode());
+            return hash;
+        }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            boolean checkChildren = v.visit(this);
+            if (checkChildren)
+            {
+                _ident.accept(v);
+                if (_optParameter != null) _optParameter.accept(v);
+            }
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<em>
+     *<li>Rule 105:  optParameter ::= $Empty
+     *</em>
+     *<p>
+     *<b>
+     *<li>Rule 106:  optParameter ::= :$ value
+     *</b>
+     */
+    static public class optParameter extends ASTNode implements IoptParameter
+    {
+        private Ivalue _value;
+
+        public Ivalue getvalue() { return _value; }
+
+        public optParameter(IToken leftIToken, IToken rightIToken,
+                            Ivalue _value)
+        {
+            super(leftIToken, rightIToken);
+
+            this._value = _value;
+            ((ASTNode) _value).setParent(this);
+            initialize();
+        }
+
+        /**
+         * A list of all children of this node, including the null ones.
+         */
+        public java.util.ArrayList getAllChildren()
+        {
+            java.util.ArrayList list = new java.util.ArrayList();
+            list.add(_value);
+            return list;
+        }
+
+        public boolean equals(Object o)
+        {
+            if (o == this) return true;
+            if (! (o instanceof optParameter)) return false;
+            if (! super.equals(o)) return false;
+            optParameter other = (optParameter) o;
+            if (! _value.equals(other._value)) return false;
+            return true;
+        }
+
+        public int hashCode()
+        {
+            int hash = super.hashCode();
+            hash = hash * 31 + (_value.hashCode());
+            return hash;
+        }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            boolean checkChildren = v.visit(this);
+            if (checkChildren)
+                _value.accept(v);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 107:  ident ::= identChars$
+     *</b>
+     */
+    static public class ident extends ASTNode implements Iident
+    {
+        public ident(IToken leftIToken, IToken rightIToken)
+        {
+            super(leftIToken, rightIToken);
+
+            initialize();
+        }
+
+        /**
+         * A list of all children of this node, including the null ones.
+         */
+        public java.util.ArrayList getAllChildren()
+        {
+            java.util.ArrayList list = new java.util.ArrayList();
+            return list;
+        }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 114:  escapedChar ::= \$ escapableChar
+     *</b>
+     */
+    static public class escapedChar extends ASTNode implements IescapedChar
+    {
+        private IescapableChar _escapableChar;
+
+        public IescapableChar getescapableChar() { return _escapableChar; }
+
+        public escapedChar(IToken leftIToken, IToken rightIToken,
+                           IescapableChar _escapableChar)
+        {
+            super(leftIToken, rightIToken);
+
+            this._escapableChar = _escapableChar;
+            ((ASTNode) _escapableChar).setParent(this);
+            initialize();
+        }
+
+        /**
+         * A list of all children of this node, including the null ones.
+         */
+        public java.util.ArrayList getAllChildren()
+        {
+            java.util.ArrayList list = new java.util.ArrayList();
+            list.add(_escapableChar);
+            return list;
+        }
+
+        public boolean equals(Object o)
+        {
+            if (o == this) return true;
+            if (! (o instanceof escapedChar)) return false;
+            if (! super.equals(o)) return false;
+            escapedChar other = (escapedChar) o;
+            if (! _escapableChar.equals(other._escapableChar)) return false;
+            return true;
+        }
+
+        public int hashCode()
+        {
+            int hash = super.hashCode();
+            hash = hash * 31 + (_escapableChar.hashCode());
+            return hash;
+        }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            boolean checkChildren = v.visit(this);
+            if (checkChildren)
+                _escapableChar.accept(v);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 118:  specialNoDollarRBrace ::= +
+     *</b>
+     */
+    static public class specialNoDollarRBrace0 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getPlus() { return leftIToken; }
+
+        public specialNoDollarRBrace0(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 119:  specialNoDollarRBrace ::= -
+     *</b>
+     */
+    static public class specialNoDollarRBrace1 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getMinus() { return leftIToken; }
+
+        public specialNoDollarRBrace1(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 120:  specialNoDollarRBrace ::= (
+     *</b>
+     */
+    static public class specialNoDollarRBrace2 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getLeftParen() { return leftIToken; }
+
+        public specialNoDollarRBrace2(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 121:  specialNoDollarRBrace ::= )
+     *</b>
+     */
+    static public class specialNoDollarRBrace3 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getRightParen() { return leftIToken; }
+
+        public specialNoDollarRBrace3(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 122:  specialNoDollarRBrace ::= "
+     *</b>
+     */
+    static public class specialNoDollarRBrace4 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getDoubleQuote() { return leftIToken; }
+
+        public specialNoDollarRBrace4(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 123:  specialNoDollarRBrace ::= !
+     *</b>
+     */
+    static public class specialNoDollarRBrace5 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getExclamation() { return leftIToken; }
+
+        public specialNoDollarRBrace5(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 124:  specialNoDollarRBrace ::= @
+     *</b>
+     */
+    static public class specialNoDollarRBrace6 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getAtSign() { return leftIToken; }
+
+        public specialNoDollarRBrace6(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 125:  specialNoDollarRBrace ::= `
+     *</b>
+     */
+    static public class specialNoDollarRBrace7 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getBackQuote() { return leftIToken; }
+
+        public specialNoDollarRBrace7(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 126:  specialNoDollarRBrace ::= ~
+     *</b>
+     */
+    static public class specialNoDollarRBrace8 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getTilde() { return leftIToken; }
+
+        public specialNoDollarRBrace8(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 127:  specialNoDollarRBrace ::= .
+     *</b>
+     */
+    static public class specialNoDollarRBrace9 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getDot() { return leftIToken; }
+
+        public specialNoDollarRBrace9(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 128:  specialNoDollarRBrace ::= /
+     *</b>
+     */
+    static public class specialNoDollarRBrace10 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getSlash() { return leftIToken; }
+
+        public specialNoDollarRBrace10(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 129:  specialNoDollarRBrace ::= %
+     *</b>
+     */
+    static public class specialNoDollarRBrace11 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getPercent() { return leftIToken; }
+
+        public specialNoDollarRBrace11(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 130:  specialNoDollarRBrace ::= &
+     *</b>
+     */
+    static public class specialNoDollarRBrace12 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getAmpersand() { return leftIToken; }
+
+        public specialNoDollarRBrace12(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 131:  specialNoDollarRBrace ::= ^
+     *</b>
+     */
+    static public class specialNoDollarRBrace13 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getCaret() { return leftIToken; }
+
+        public specialNoDollarRBrace13(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 132:  specialNoDollarRBrace ::= :
+     *</b>
+     */
+    static public class specialNoDollarRBrace14 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getColon() { return leftIToken; }
+
+        public specialNoDollarRBrace14(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 133:  specialNoDollarRBrace ::= ;
+     *</b>
+     */
+    static public class specialNoDollarRBrace15 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getSemiColon() { return leftIToken; }
+
+        public specialNoDollarRBrace15(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 134:  specialNoDollarRBrace ::= '
+     *</b>
+     */
+    static public class specialNoDollarRBrace16 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getSingleQuote() { return leftIToken; }
+
+        public specialNoDollarRBrace16(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 135:  specialNoDollarRBrace ::= |
+     *</b>
+     */
+    static public class specialNoDollarRBrace17 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getVerticalBar() { return leftIToken; }
+
+        public specialNoDollarRBrace17(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 136:  specialNoDollarRBrace ::= {
+     *</b>
+     */
+    static public class specialNoDollarRBrace18 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getLeftBrace() { return leftIToken; }
+
+        public specialNoDollarRBrace18(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 137:  specialNoDollarRBrace ::=  
+     *</b>
+     */
+    static public class specialNoDollarRBrace19 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getSpace() { return leftIToken; }
+
+        public specialNoDollarRBrace19(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 138:  specialNoDollarRBrace ::= [
+     *</b>
+     */
+    static public class specialNoDollarRBrace20 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getLeftBracket() { return leftIToken; }
+
+        public specialNoDollarRBrace20(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 139:  specialNoDollarRBrace ::= ]
+     *</b>
+     */
+    static public class specialNoDollarRBrace21 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getRightBracket() { return leftIToken; }
+
+        public specialNoDollarRBrace21(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 140:  specialNoDollarRBrace ::= ?
+     *</b>
+     */
+    static public class specialNoDollarRBrace22 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getQuestionMark() { return leftIToken; }
+
+        public specialNoDollarRBrace22(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 141:  specialNoDollarRBrace ::= ,
+     *</b>
+     */
+    static public class specialNoDollarRBrace23 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getComma() { return leftIToken; }
+
+        public specialNoDollarRBrace23(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 142:  specialNoDollarRBrace ::= <
+     *</b>
+     */
+    static public class specialNoDollarRBrace24 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getLessThan() { return leftIToken; }
+
+        public specialNoDollarRBrace24(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 143:  specialNoDollarRBrace ::= >
+     *</b>
+     */
+    static public class specialNoDollarRBrace25 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getGreaterThan() { return leftIToken; }
+
+        public specialNoDollarRBrace25(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 144:  specialNoDollarRBrace ::= =
+     *</b>
+     */
+    static public class specialNoDollarRBrace26 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getEqual() { return leftIToken; }
+
+        public specialNoDollarRBrace26(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 145:  specialNoDollarRBrace ::= #
+     *</b>
+     */
+    static public class specialNoDollarRBrace27 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getSharp() { return leftIToken; }
+
+        public specialNoDollarRBrace27(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 146:  specialNoDollarRBrace ::= *
+     *</b>
+     */
+    static public class specialNoDollarRBrace28 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken getStar() { return leftIToken; }
+
+        public specialNoDollarRBrace28(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 147:  specialNoDollarRBrace ::= _
+     *</b>
+     */
+    static public class specialNoDollarRBrace29 extends ASTNodeToken implements IspecialNoDollarRBrace
+    {
+        public IToken get_() { return leftIToken; }
+
+        public specialNoDollarRBrace29(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 148:  special ::= +
+     *</b>
+     */
+    static public class special0 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getPlus() { return leftIToken; }
+
+        public special0(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 149:  special ::= -
+     *</b>
+     */
+    static public class special1 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getMinus() { return leftIToken; }
+
+        public special1(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 150:  special ::= (
+     *</b>
+     */
+    static public class special2 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getLeftParen() { return leftIToken; }
+
+        public special2(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 151:  special ::= )
+     *</b>
+     */
+    static public class special3 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getRightParen() { return leftIToken; }
+
+        public special3(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 152:  special ::= "
+     *</b>
+     */
+    static public class special4 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getDoubleQuote() { return leftIToken; }
+
+        public special4(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 153:  special ::= !
+     *</b>
+     */
+    static public class special5 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getExclamation() { return leftIToken; }
+
+        public special5(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 154:  special ::= @
+     *</b>
+     */
+    static public class special6 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getAtSign() { return leftIToken; }
+
+        public special6(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 155:  special ::= `
+     *</b>
+     */
+    static public class special7 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getBackQuote() { return leftIToken; }
+
+        public special7(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 156:  special ::= ~
+     *</b>
+     */
+    static public class special8 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getTilde() { return leftIToken; }
+
+        public special8(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 157:  special ::= .
+     *</b>
+     */
+    static public class special9 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getDot() { return leftIToken; }
+
+        public special9(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 158:  special ::= /
+     *</b>
+     */
+    static public class special10 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getSlash() { return leftIToken; }
+
+        public special10(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 159:  special ::= %
+     *</b>
+     */
+    static public class special11 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getPercent() { return leftIToken; }
+
+        public special11(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 160:  special ::= &
+     *</b>
+     */
+    static public class special12 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getAmpersand() { return leftIToken; }
+
+        public special12(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 161:  special ::= ^
+     *</b>
+     */
+    static public class special13 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getCaret() { return leftIToken; }
+
+        public special13(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 162:  special ::= :
+     *</b>
+     */
+    static public class special14 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getColon() { return leftIToken; }
+
+        public special14(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 163:  special ::= ;
+     *</b>
+     */
+    static public class special15 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getSemiColon() { return leftIToken; }
+
+        public special15(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 164:  special ::= '
+     *</b>
+     */
+    static public class special16 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getSingleQuote() { return leftIToken; }
+
+        public special16(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 165:  special ::= \
+     *</b>
+     */
+    static public class special17 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getBackSlash() { return leftIToken; }
+
+        public special17(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 166:  special ::= |
+     *</b>
+     */
+    static public class special18 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getVerticalBar() { return leftIToken; }
+
+        public special18(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 167:  special ::= {
+     *</b>
+     */
+    static public class special19 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getLeftBrace() { return leftIToken; }
+
+        public special19(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 168:  special ::=  
+     *</b>
+     */
+    static public class special20 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getSpace() { return leftIToken; }
+
+        public special20(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 169:  special ::= }
+     *</b>
+     */
+    static public class special21 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getRightBrace() { return leftIToken; }
+
+        public special21(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 170:  special ::= [
+     *</b>
+     */
+    static public class special22 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getLeftBracket() { return leftIToken; }
+
+        public special22(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 171:  special ::= ]
+     *</b>
+     */
+    static public class special23 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getRightBracket() { return leftIToken; }
+
+        public special23(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 172:  special ::= ?
+     *</b>
+     */
+    static public class special24 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getQuestionMark() { return leftIToken; }
+
+        public special24(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 173:  special ::= ,
+     *</b>
+     */
+    static public class special25 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getComma() { return leftIToken; }
+
+        public special25(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 174:  special ::= <
+     *</b>
+     */
+    static public class special26 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getLessThan() { return leftIToken; }
+
+        public special26(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 175:  special ::= >
+     *</b>
+     */
+    static public class special27 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getGreaterThan() { return leftIToken; }
+
+        public special27(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 176:  special ::= =
+     *</b>
+     */
+    static public class special28 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getEqual() { return leftIToken; }
+
+        public special28(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 177:  special ::= #
+     *</b>
+     */
+    static public class special29 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getSharp() { return leftIToken; }
+
+        public special29(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 178:  special ::= *
+     *</b>
+     */
+    static public class special30 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getStar() { return leftIToken; }
+
+        public special30(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 179:  special ::= _
+     *</b>
+     */
+    static public class special31 extends ASTNodeToken implements Ispecial
+    {
+        public IToken get_() { return leftIToken; }
+
+        public special31(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    /**
+     *<b>
+     *<li>Rule 180:  special ::= $
+     *</b>
+     */
+    static public class special32 extends ASTNodeToken implements Ispecial
+    {
+        public IToken getDollarSign() { return leftIToken; }
+
+        public special32(IToken token) { super(token); initialize(); }
+
+        public void accept(IAstVisitor v)
+        {
+            if (! v.preVisit(this)) return;
+            enter((Visitor) v);
+            v.postVisit(this);
+        }
+
+        public void enter(Visitor v)
+        {
+            v.visit(this);
+            v.endVisit(this);
+        }
+    }
+
+    public interface Visitor extends IAstVisitor
+    {
+        boolean visit(ASTNode n);
+        void endVisit(ASTNode n);
+
+        boolean visit(ASTNodeToken n);
+        void endVisit(ASTNodeToken n);
+
+        boolean visit(simpleStringPrefixed n);
+        void endVisit(simpleStringPrefixed n);
+
+        boolean visit(valStringNoSubst n);
+        void endVisit(valStringNoSubst n);
+
+        boolean visit(substPrefixed n);
+        void endVisit(substPrefixed n);
+
+        boolean visit(substitutionList n);
+        void endVisit(substitutionList n);
+
+        boolean visit(substitution n);
+        void endVisit(substitution n);
+
+        boolean visit(optParameter n);
+        void endVisit(optParameter n);
+
+        boolean visit(ident n);
+        void endVisit(ident n);
+
+        boolean visit(escapedChar n);
+        void endVisit(escapedChar n);
+
+        boolean visit(specialNoDollarRBrace0 n);
+        void endVisit(specialNoDollarRBrace0 n);
+
+        boolean visit(specialNoDollarRBrace1 n);
+        void endVisit(specialNoDollarRBrace1 n);
+
+        boolean visit(specialNoDollarRBrace2 n);
+        void endVisit(specialNoDollarRBrace2 n);
+
+        boolean visit(specialNoDollarRBrace3 n);
+        void endVisit(specialNoDollarRBrace3 n);
+
+        boolean visit(specialNoDollarRBrace4 n);
+        void endVisit(specialNoDollarRBrace4 n);
+
+        boolean visit(specialNoDollarRBrace5 n);
+        void endVisit(specialNoDollarRBrace5 n);
+
+        boolean visit(specialNoDollarRBrace6 n);
+        void endVisit(specialNoDollarRBrace6 n);
+
+        boolean visit(specialNoDollarRBrace7 n);
+        void endVisit(specialNoDollarRBrace7 n);
+
+        boolean visit(specialNoDollarRBrace8 n);
+        void endVisit(specialNoDollarRBrace8 n);
+
+        boolean visit(specialNoDollarRBrace9 n);
+        void endVisit(specialNoDollarRBrace9 n);
+
+        boolean visit(specialNoDollarRBrace10 n);
+        void endVisit(specialNoDollarRBrace10 n);
+
+        boolean visit(specialNoDollarRBrace11 n);
+        void endVisit(specialNoDollarRBrace11 n);
+
+        boolean visit(specialNoDollarRBrace12 n);
+        void endVisit(specialNoDollarRBrace12 n);
+
+        boolean visit(specialNoDollarRBrace13 n);
+        void endVisit(specialNoDollarRBrace13 n);
+
+        boolean visit(specialNoDollarRBrace14 n);
+        void endVisit(specialNoDollarRBrace14 n);
+
+        boolean visit(specialNoDollarRBrace15 n);
+        void endVisit(specialNoDollarRBrace15 n);
+
+        boolean visit(specialNoDollarRBrace16 n);
+        void endVisit(specialNoDollarRBrace16 n);
+
+        boolean visit(specialNoDollarRBrace17 n);
+        void endVisit(specialNoDollarRBrace17 n);
+
+        boolean visit(specialNoDollarRBrace18 n);
+        void endVisit(specialNoDollarRBrace18 n);
+
+        boolean visit(specialNoDollarRBrace19 n);
+        void endVisit(specialNoDollarRBrace19 n);
+
+        boolean visit(specialNoDollarRBrace20 n);
+        void endVisit(specialNoDollarRBrace20 n);
+
+        boolean visit(specialNoDollarRBrace21 n);
+        void endVisit(specialNoDollarRBrace21 n);
+
+        boolean visit(specialNoDollarRBrace22 n);
+        void endVisit(specialNoDollarRBrace22 n);
+
+        boolean visit(specialNoDollarRBrace23 n);
+        void endVisit(specialNoDollarRBrace23 n);
+
+        boolean visit(specialNoDollarRBrace24 n);
+        void endVisit(specialNoDollarRBrace24 n);
+
+        boolean visit(specialNoDollarRBrace25 n);
+        void endVisit(specialNoDollarRBrace25 n);
+
+        boolean visit(specialNoDollarRBrace26 n);
+        void endVisit(specialNoDollarRBrace26 n);
+
+        boolean visit(specialNoDollarRBrace27 n);
+        void endVisit(specialNoDollarRBrace27 n);
+
+        boolean visit(specialNoDollarRBrace28 n);
+        void endVisit(specialNoDollarRBrace28 n);
+
+        boolean visit(specialNoDollarRBrace29 n);
+        void endVisit(specialNoDollarRBrace29 n);
+
+        boolean visit(special0 n);
+        void endVisit(special0 n);
+
+        boolean visit(special1 n);
+        void endVisit(special1 n);
+
+        boolean visit(special2 n);
+        void endVisit(special2 n);
+
+        boolean visit(special3 n);
+        void endVisit(special3 n);
+
+        boolean visit(special4 n);
+        void endVisit(special4 n);
+
+        boolean visit(special5 n);
+        void endVisit(special5 n);
+
+        boolean visit(special6 n);
+        void endVisit(special6 n);
+
+        boolean visit(special7 n);
+        void endVisit(special7 n);
+
+        boolean visit(special8 n);
+        void endVisit(special8 n);
+
+        boolean visit(special9 n);
+        void endVisit(special9 n);
+
+        boolean visit(special10 n);
+        void endVisit(special10 n);
+
+        boolean visit(special11 n);
+        void endVisit(special11 n);
+
+        boolean visit(special12 n);
+        void endVisit(special12 n);
+
+        boolean visit(special13 n);
+        void endVisit(special13 n);
+
+        boolean visit(special14 n);
+        void endVisit(special14 n);
+
+        boolean visit(special15 n);
+        void endVisit(special15 n);
+
+        boolean visit(special16 n);
+        void endVisit(special16 n);
+
+        boolean visit(special17 n);
+        void endVisit(special17 n);
+
+        boolean visit(special18 n);
+        void endVisit(special18 n);
+
+        boolean visit(special19 n);
+        void endVisit(special19 n);
+
+        boolean visit(special20 n);
+        void endVisit(special20 n);
+
+        boolean visit(special21 n);
+        void endVisit(special21 n);
+
+        boolean visit(special22 n);
+        void endVisit(special22 n);
+
+        boolean visit(special23 n);
+        void endVisit(special23 n);
+
+        boolean visit(special24 n);
+        void endVisit(special24 n);
+
+        boolean visit(special25 n);
+        void endVisit(special25 n);
+
+        boolean visit(special26 n);
+        void endVisit(special26 n);
+
+        boolean visit(special27 n);
+        void endVisit(special27 n);
+
+        boolean visit(special28 n);
+        void endVisit(special28 n);
+
+        boolean visit(special29 n);
+        void endVisit(special29 n);
+
+        boolean visit(special30 n);
+        void endVisit(special30 n);
+
+        boolean visit(special31 n);
+        void endVisit(special31 n);
+
+        boolean visit(special32 n);
+        void endVisit(special32 n);
+
+    }
+
+    static public abstract class AbstractVisitor implements Visitor
+    {
+        public abstract void unimplementedVisitor(String s);
+
+        public boolean preVisit(IAst element) { return true; }
+
+        public void postVisit(IAst element) {}
+
+        public boolean visit(ASTNodeToken n) { unimplementedVisitor("visit(ASTNodeToken)"); return true; }
+        public void endVisit(ASTNodeToken n) { unimplementedVisitor("endVisit(ASTNodeToken)"); }
+
+        public boolean visit(simpleStringPrefixed n) { unimplementedVisitor("visit(simpleStringPrefixed)"); return true; }
+        public void endVisit(simpleStringPrefixed n) { unimplementedVisitor("endVisit(simpleStringPrefixed)"); }
+
+        public boolean visit(valStringNoSubst n) { unimplementedVisitor("visit(valStringNoSubst)"); return true; }
+        public void endVisit(valStringNoSubst n) { unimplementedVisitor("endVisit(valStringNoSubst)"); }
+
+        public boolean visit(substPrefixed n) { unimplementedVisitor("visit(substPrefixed)"); return true; }
+        public void endVisit(substPrefixed n) { unimplementedVisitor("endVisit(substPrefixed)"); }
+
+        public boolean visit(substitutionList n) { unimplementedVisitor("visit(substitutionList)"); return true; }
+        public void endVisit(substitutionList n) { unimplementedVisitor("endVisit(substitutionList)"); }
+
+        public boolean visit(substitution n) { unimplementedVisitor("visit(substitution)"); return true; }
+        public void endVisit(substitution n) { unimplementedVisitor("endVisit(substitution)"); }
+
+        public boolean visit(optParameter n) { unimplementedVisitor("visit(optParameter)"); return true; }
+        public void endVisit(optParameter n) { unimplementedVisitor("endVisit(optParameter)"); }
+
+        public boolean visit(ident n) { unimplementedVisitor("visit(ident)"); return true; }
+        public void endVisit(ident n) { unimplementedVisitor("endVisit(ident)"); }
+
+        public boolean visit(escapedChar n) { unimplementedVisitor("visit(escapedChar)"); return true; }
+        public void endVisit(escapedChar n) { unimplementedVisitor("endVisit(escapedChar)"); }
+
+        public boolean visit(specialNoDollarRBrace0 n) { unimplementedVisitor("visit(specialNoDollarRBrace0)"); return true; }
+        public void endVisit(specialNoDollarRBrace0 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace0)"); }
+
+        public boolean visit(specialNoDollarRBrace1 n) { unimplementedVisitor("visit(specialNoDollarRBrace1)"); return true; }
+        public void endVisit(specialNoDollarRBrace1 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace1)"); }
+
+        public boolean visit(specialNoDollarRBrace2 n) { unimplementedVisitor("visit(specialNoDollarRBrace2)"); return true; }
+        public void endVisit(specialNoDollarRBrace2 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace2)"); }
+
+        public boolean visit(specialNoDollarRBrace3 n) { unimplementedVisitor("visit(specialNoDollarRBrace3)"); return true; }
+        public void endVisit(specialNoDollarRBrace3 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace3)"); }
+
+        public boolean visit(specialNoDollarRBrace4 n) { unimplementedVisitor("visit(specialNoDollarRBrace4)"); return true; }
+        public void endVisit(specialNoDollarRBrace4 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace4)"); }
+
+        public boolean visit(specialNoDollarRBrace5 n) { unimplementedVisitor("visit(specialNoDollarRBrace5)"); return true; }
+        public void endVisit(specialNoDollarRBrace5 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace5)"); }
+
+        public boolean visit(specialNoDollarRBrace6 n) { unimplementedVisitor("visit(specialNoDollarRBrace6)"); return true; }
+        public void endVisit(specialNoDollarRBrace6 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace6)"); }
+
+        public boolean visit(specialNoDollarRBrace7 n) { unimplementedVisitor("visit(specialNoDollarRBrace7)"); return true; }
+        public void endVisit(specialNoDollarRBrace7 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace7)"); }
+
+        public boolean visit(specialNoDollarRBrace8 n) { unimplementedVisitor("visit(specialNoDollarRBrace8)"); return true; }
+        public void endVisit(specialNoDollarRBrace8 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace8)"); }
+
+        public boolean visit(specialNoDollarRBrace9 n) { unimplementedVisitor("visit(specialNoDollarRBrace9)"); return true; }
+        public void endVisit(specialNoDollarRBrace9 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace9)"); }
+
+        public boolean visit(specialNoDollarRBrace10 n) { unimplementedVisitor("visit(specialNoDollarRBrace10)"); return true; }
+        public void endVisit(specialNoDollarRBrace10 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace10)"); }
+
+        public boolean visit(specialNoDollarRBrace11 n) { unimplementedVisitor("visit(specialNoDollarRBrace11)"); return true; }
+        public void endVisit(specialNoDollarRBrace11 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace11)"); }
+
+        public boolean visit(specialNoDollarRBrace12 n) { unimplementedVisitor("visit(specialNoDollarRBrace12)"); return true; }
+        public void endVisit(specialNoDollarRBrace12 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace12)"); }
+
+        public boolean visit(specialNoDollarRBrace13 n) { unimplementedVisitor("visit(specialNoDollarRBrace13)"); return true; }
+        public void endVisit(specialNoDollarRBrace13 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace13)"); }
+
+        public boolean visit(specialNoDollarRBrace14 n) { unimplementedVisitor("visit(specialNoDollarRBrace14)"); return true; }
+        public void endVisit(specialNoDollarRBrace14 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace14)"); }
+
+        public boolean visit(specialNoDollarRBrace15 n) { unimplementedVisitor("visit(specialNoDollarRBrace15)"); return true; }
+        public void endVisit(specialNoDollarRBrace15 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace15)"); }
+
+        public boolean visit(specialNoDollarRBrace16 n) { unimplementedVisitor("visit(specialNoDollarRBrace16)"); return true; }
+        public void endVisit(specialNoDollarRBrace16 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace16)"); }
+
+        public boolean visit(specialNoDollarRBrace17 n) { unimplementedVisitor("visit(specialNoDollarRBrace17)"); return true; }
+        public void endVisit(specialNoDollarRBrace17 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace17)"); }
+
+        public boolean visit(specialNoDollarRBrace18 n) { unimplementedVisitor("visit(specialNoDollarRBrace18)"); return true; }
+        public void endVisit(specialNoDollarRBrace18 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace18)"); }
+
+        public boolean visit(specialNoDollarRBrace19 n) { unimplementedVisitor("visit(specialNoDollarRBrace19)"); return true; }
+        public void endVisit(specialNoDollarRBrace19 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace19)"); }
+
+        public boolean visit(specialNoDollarRBrace20 n) { unimplementedVisitor("visit(specialNoDollarRBrace20)"); return true; }
+        public void endVisit(specialNoDollarRBrace20 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace20)"); }
+
+        public boolean visit(specialNoDollarRBrace21 n) { unimplementedVisitor("visit(specialNoDollarRBrace21)"); return true; }
+        public void endVisit(specialNoDollarRBrace21 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace21)"); }
+
+        public boolean visit(specialNoDollarRBrace22 n) { unimplementedVisitor("visit(specialNoDollarRBrace22)"); return true; }
+        public void endVisit(specialNoDollarRBrace22 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace22)"); }
+
+        public boolean visit(specialNoDollarRBrace23 n) { unimplementedVisitor("visit(specialNoDollarRBrace23)"); return true; }
+        public void endVisit(specialNoDollarRBrace23 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace23)"); }
+
+        public boolean visit(specialNoDollarRBrace24 n) { unimplementedVisitor("visit(specialNoDollarRBrace24)"); return true; }
+        public void endVisit(specialNoDollarRBrace24 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace24)"); }
+
+        public boolean visit(specialNoDollarRBrace25 n) { unimplementedVisitor("visit(specialNoDollarRBrace25)"); return true; }
+        public void endVisit(specialNoDollarRBrace25 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace25)"); }
+
+        public boolean visit(specialNoDollarRBrace26 n) { unimplementedVisitor("visit(specialNoDollarRBrace26)"); return true; }
+        public void endVisit(specialNoDollarRBrace26 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace26)"); }
+
+        public boolean visit(specialNoDollarRBrace27 n) { unimplementedVisitor("visit(specialNoDollarRBrace27)"); return true; }
+        public void endVisit(specialNoDollarRBrace27 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace27)"); }
+
+        public boolean visit(specialNoDollarRBrace28 n) { unimplementedVisitor("visit(specialNoDollarRBrace28)"); return true; }
+        public void endVisit(specialNoDollarRBrace28 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace28)"); }
+
+        public boolean visit(specialNoDollarRBrace29 n) { unimplementedVisitor("visit(specialNoDollarRBrace29)"); return true; }
+        public void endVisit(specialNoDollarRBrace29 n) { unimplementedVisitor("endVisit(specialNoDollarRBrace29)"); }
+
+        public boolean visit(special0 n) { unimplementedVisitor("visit(special0)"); return true; }
+        public void endVisit(special0 n) { unimplementedVisitor("endVisit(special0)"); }
+
+        public boolean visit(special1 n) { unimplementedVisitor("visit(special1)"); return true; }
+        public void endVisit(special1 n) { unimplementedVisitor("endVisit(special1)"); }
+
+        public boolean visit(special2 n) { unimplementedVisitor("visit(special2)"); return true; }
+        public void endVisit(special2 n) { unimplementedVisitor("endVisit(special2)"); }
+
+        public boolean visit(special3 n) { unimplementedVisitor("visit(special3)"); return true; }
+        public void endVisit(special3 n) { unimplementedVisitor("endVisit(special3)"); }
+
+        public boolean visit(special4 n) { unimplementedVisitor("visit(special4)"); return true; }
+        public void endVisit(special4 n) { unimplementedVisitor("endVisit(special4)"); }
+
+        public boolean visit(special5 n) { unimplementedVisitor("visit(special5)"); return true; }
+        public void endVisit(special5 n) { unimplementedVisitor("endVisit(special5)"); }
+
+        public boolean visit(special6 n) { unimplementedVisitor("visit(special6)"); return true; }
+        public void endVisit(special6 n) { unimplementedVisitor("endVisit(special6)"); }
+
+        public boolean visit(special7 n) { unimplementedVisitor("visit(special7)"); return true; }
+        public void endVisit(special7 n) { unimplementedVisitor("endVisit(special7)"); }
+
+        public boolean visit(special8 n) { unimplementedVisitor("visit(special8)"); return true; }
+        public void endVisit(special8 n) { unimplementedVisitor("endVisit(special8)"); }
+
+        public boolean visit(special9 n) { unimplementedVisitor("visit(special9)"); return true; }
+        public void endVisit(special9 n) { unimplementedVisitor("endVisit(special9)"); }
+
+        public boolean visit(special10 n) { unimplementedVisitor("visit(special10)"); return true; }
+        public void endVisit(special10 n) { unimplementedVisitor("endVisit(special10)"); }
+
+        public boolean visit(special11 n) { unimplementedVisitor("visit(special11)"); return true; }
+        public void endVisit(special11 n) { unimplementedVisitor("endVisit(special11)"); }
+
+        public boolean visit(special12 n) { unimplementedVisitor("visit(special12)"); return true; }
+        public void endVisit(special12 n) { unimplementedVisitor("endVisit(special12)"); }
+
+        public boolean visit(special13 n) { unimplementedVisitor("visit(special13)"); return true; }
+        public void endVisit(special13 n) { unimplementedVisitor("endVisit(special13)"); }
+
+        public boolean visit(special14 n) { unimplementedVisitor("visit(special14)"); return true; }
+        public void endVisit(special14 n) { unimplementedVisitor("endVisit(special14)"); }
+
+        public boolean visit(special15 n) { unimplementedVisitor("visit(special15)"); return true; }
+        public void endVisit(special15 n) { unimplementedVisitor("endVisit(special15)"); }
+
+        public boolean visit(special16 n) { unimplementedVisitor("visit(special16)"); return true; }
+        public void endVisit(special16 n) { unimplementedVisitor("endVisit(special16)"); }
+
+        public boolean visit(special17 n) { unimplementedVisitor("visit(special17)"); return true; }
+        public void endVisit(special17 n) { unimplementedVisitor("endVisit(special17)"); }
+
+        public boolean visit(special18 n) { unimplementedVisitor("visit(special18)"); return true; }
+        public void endVisit(special18 n) { unimplementedVisitor("endVisit(special18)"); }
+
+        public boolean visit(special19 n) { unimplementedVisitor("visit(special19)"); return true; }
+        public void endVisit(special19 n) { unimplementedVisitor("endVisit(special19)"); }
+
+        public boolean visit(special20 n) { unimplementedVisitor("visit(special20)"); return true; }
+        public void endVisit(special20 n) { unimplementedVisitor("endVisit(special20)"); }
+
+        public boolean visit(special21 n) { unimplementedVisitor("visit(special21)"); return true; }
+        public void endVisit(special21 n) { unimplementedVisitor("endVisit(special21)"); }
+
+        public boolean visit(special22 n) { unimplementedVisitor("visit(special22)"); return true; }
+        public void endVisit(special22 n) { unimplementedVisitor("endVisit(special22)"); }
+
+        public boolean visit(special23 n) { unimplementedVisitor("visit(special23)"); return true; }
+        public void endVisit(special23 n) { unimplementedVisitor("endVisit(special23)"); }
+
+        public boolean visit(special24 n) { unimplementedVisitor("visit(special24)"); return true; }
+        public void endVisit(special24 n) { unimplementedVisitor("endVisit(special24)"); }
+
+        public boolean visit(special25 n) { unimplementedVisitor("visit(special25)"); return true; }
+        public void endVisit(special25 n) { unimplementedVisitor("endVisit(special25)"); }
+
+        public boolean visit(special26 n) { unimplementedVisitor("visit(special26)"); return true; }
+        public void endVisit(special26 n) { unimplementedVisitor("endVisit(special26)"); }
+
+        public boolean visit(special27 n) { unimplementedVisitor("visit(special27)"); return true; }
+        public void endVisit(special27 n) { unimplementedVisitor("endVisit(special27)"); }
+
+        public boolean visit(special28 n) { unimplementedVisitor("visit(special28)"); return true; }
+        public void endVisit(special28 n) { unimplementedVisitor("endVisit(special28)"); }
+
+        public boolean visit(special29 n) { unimplementedVisitor("visit(special29)"); return true; }
+        public void endVisit(special29 n) { unimplementedVisitor("endVisit(special29)"); }
+
+        public boolean visit(special30 n) { unimplementedVisitor("visit(special30)"); return true; }
+        public void endVisit(special30 n) { unimplementedVisitor("endVisit(special30)"); }
+
+        public boolean visit(special31 n) { unimplementedVisitor("visit(special31)"); return true; }
+        public void endVisit(special31 n) { unimplementedVisitor("endVisit(special31)"); }
+
+        public boolean visit(special32 n) { unimplementedVisitor("visit(special32)"); return true; }
+        public void endVisit(special32 n) { unimplementedVisitor("endVisit(special32)"); }
+
+
+        public boolean visit(ASTNode n)
+        {
+            if (n instanceof ASTNodeToken) return visit((ASTNodeToken) n);
+            else if (n instanceof simpleStringPrefixed) return visit((simpleStringPrefixed) n);
+            else if (n instanceof valStringNoSubst) return visit((valStringNoSubst) n);
+            else if (n instanceof substPrefixed) return visit((substPrefixed) n);
+            else if (n instanceof substitutionList) return visit((substitutionList) n);
+            else if (n instanceof substitution) return visit((substitution) n);
+            else if (n instanceof optParameter) return visit((optParameter) n);
+            else if (n instanceof ident) return visit((ident) n);
+            else if (n instanceof escapedChar) return visit((escapedChar) n);
+            else if (n instanceof specialNoDollarRBrace0) return visit((specialNoDollarRBrace0) n);
+            else if (n instanceof specialNoDollarRBrace1) return visit((specialNoDollarRBrace1) n);
+            else if (n instanceof specialNoDollarRBrace2) return visit((specialNoDollarRBrace2) n);
+            else if (n instanceof specialNoDollarRBrace3) return visit((specialNoDollarRBrace3) n);
+            else if (n instanceof specialNoDollarRBrace4) return visit((specialNoDollarRBrace4) n);
+            else if (n instanceof specialNoDollarRBrace5) return visit((specialNoDollarRBrace5) n);
+            else if (n instanceof specialNoDollarRBrace6) return visit((specialNoDollarRBrace6) n);
+            else if (n instanceof specialNoDollarRBrace7) return visit((specialNoDollarRBrace7) n);
+            else if (n instanceof specialNoDollarRBrace8) return visit((specialNoDollarRBrace8) n);
+            else if (n instanceof specialNoDollarRBrace9) return visit((specialNoDollarRBrace9) n);
+            else if (n instanceof specialNoDollarRBrace10) return visit((specialNoDollarRBrace10) n);
+            else if (n instanceof specialNoDollarRBrace11) return visit((specialNoDollarRBrace11) n);
+            else if (n instanceof specialNoDollarRBrace12) return visit((specialNoDollarRBrace12) n);
+            else if (n instanceof specialNoDollarRBrace13) return visit((specialNoDollarRBrace13) n);
+            else if (n instanceof specialNoDollarRBrace14) return visit((specialNoDollarRBrace14) n);
+            else if (n instanceof specialNoDollarRBrace15) return visit((specialNoDollarRBrace15) n);
+            else if (n instanceof specialNoDollarRBrace16) return visit((specialNoDollarRBrace16) n);
+            else if (n instanceof specialNoDollarRBrace17) return visit((specialNoDollarRBrace17) n);
+            else if (n instanceof specialNoDollarRBrace18) return visit((specialNoDollarRBrace18) n);
+            else if (n instanceof specialNoDollarRBrace19) return visit((specialNoDollarRBrace19) n);
+            else if (n instanceof specialNoDollarRBrace20) return visit((specialNoDollarRBrace20) n);
+            else if (n instanceof specialNoDollarRBrace21) return visit((specialNoDollarRBrace21) n);
+            else if (n instanceof specialNoDollarRBrace22) return visit((specialNoDollarRBrace22) n);
+            else if (n instanceof specialNoDollarRBrace23) return visit((specialNoDollarRBrace23) n);
+            else if (n instanceof specialNoDollarRBrace24) return visit((specialNoDollarRBrace24) n);
+            else if (n instanceof specialNoDollarRBrace25) return visit((specialNoDollarRBrace25) n);
+            else if (n instanceof specialNoDollarRBrace26) return visit((specialNoDollarRBrace26) n);
+            else if (n instanceof specialNoDollarRBrace27) return visit((specialNoDollarRBrace27) n);
+            else if (n instanceof specialNoDollarRBrace28) return visit((specialNoDollarRBrace28) n);
+            else if (n instanceof specialNoDollarRBrace29) return visit((specialNoDollarRBrace29) n);
+            else if (n instanceof special0) return visit((special0) n);
+            else if (n instanceof special1) return visit((special1) n);
+            else if (n instanceof special2) return visit((special2) n);
+            else if (n instanceof special3) return visit((special3) n);
+            else if (n instanceof special4) return visit((special4) n);
+            else if (n instanceof special5) return visit((special5) n);
+            else if (n instanceof special6) return visit((special6) n);
+            else if (n instanceof special7) return visit((special7) n);
+            else if (n instanceof special8) return visit((special8) n);
+            else if (n instanceof special9) return visit((special9) n);
+            else if (n instanceof special10) return visit((special10) n);
+            else if (n instanceof special11) return visit((special11) n);
+            else if (n instanceof special12) return visit((special12) n);
+            else if (n instanceof special13) return visit((special13) n);
+            else if (n instanceof special14) return visit((special14) n);
+            else if (n instanceof special15) return visit((special15) n);
+            else if (n instanceof special16) return visit((special16) n);
+            else if (n instanceof special17) return visit((special17) n);
+            else if (n instanceof special18) return visit((special18) n);
+            else if (n instanceof special19) return visit((special19) n);
+            else if (n instanceof special20) return visit((special20) n);
+            else if (n instanceof special21) return visit((special21) n);
+            else if (n instanceof special22) return visit((special22) n);
+            else if (n instanceof special23) return visit((special23) n);
+            else if (n instanceof special24) return visit((special24) n);
+            else if (n instanceof special25) return visit((special25) n);
+            else if (n instanceof special26) return visit((special26) n);
+            else if (n instanceof special27) return visit((special27) n);
+            else if (n instanceof special28) return visit((special28) n);
+            else if (n instanceof special29) return visit((special29) n);
+            else if (n instanceof special30) return visit((special30) n);
+            else if (n instanceof special31) return visit((special31) n);
+            else if (n instanceof special32) return visit((special32) n);
+            throw new UnsupportedOperationException("visit(" + n.getClass().toString() + ")");
+        }
+        public void endVisit(ASTNode n)
+        {
+            if (n instanceof ASTNodeToken) endVisit((ASTNodeToken) n);
+            else if (n instanceof simpleStringPrefixed) endVisit((simpleStringPrefixed) n);
+            else if (n instanceof valStringNoSubst) endVisit((valStringNoSubst) n);
+            else if (n instanceof substPrefixed) endVisit((substPrefixed) n);
+            else if (n instanceof substitutionList) endVisit((substitutionList) n);
+            else if (n instanceof substitution) endVisit((substitution) n);
+            else if (n instanceof optParameter) endVisit((optParameter) n);
+            else if (n instanceof ident) endVisit((ident) n);
+            else if (n instanceof escapedChar) endVisit((escapedChar) n);
+            else if (n instanceof specialNoDollarRBrace0) endVisit((specialNoDollarRBrace0) n);
+            else if (n instanceof specialNoDollarRBrace1) endVisit((specialNoDollarRBrace1) n);
+            else if (n instanceof specialNoDollarRBrace2) endVisit((specialNoDollarRBrace2) n);
+            else if (n instanceof specialNoDollarRBrace3) endVisit((specialNoDollarRBrace3) n);
+            else if (n instanceof specialNoDollarRBrace4) endVisit((specialNoDollarRBrace4) n);
+            else if (n instanceof specialNoDollarRBrace5) endVisit((specialNoDollarRBrace5) n);
+            else if (n instanceof specialNoDollarRBrace6) endVisit((specialNoDollarRBrace6) n);
+            else if (n instanceof specialNoDollarRBrace7) endVisit((specialNoDollarRBrace7) n);
+            else if (n instanceof specialNoDollarRBrace8) endVisit((specialNoDollarRBrace8) n);
+            else if (n instanceof specialNoDollarRBrace9) endVisit((specialNoDollarRBrace9) n);
+            else if (n instanceof specialNoDollarRBrace10) endVisit((specialNoDollarRBrace10) n);
+            else if (n instanceof specialNoDollarRBrace11) endVisit((specialNoDollarRBrace11) n);
+            else if (n instanceof specialNoDollarRBrace12) endVisit((specialNoDollarRBrace12) n);
+            else if (n instanceof specialNoDollarRBrace13) endVisit((specialNoDollarRBrace13) n);
+            else if (n instanceof specialNoDollarRBrace14) endVisit((specialNoDollarRBrace14) n);
+            else if (n instanceof specialNoDollarRBrace15) endVisit((specialNoDollarRBrace15) n);
+            else if (n instanceof specialNoDollarRBrace16) endVisit((specialNoDollarRBrace16) n);
+            else if (n instanceof specialNoDollarRBrace17) endVisit((specialNoDollarRBrace17) n);
+            else if (n instanceof specialNoDollarRBrace18) endVisit((specialNoDollarRBrace18) n);
+            else if (n instanceof specialNoDollarRBrace19) endVisit((specialNoDollarRBrace19) n);
+            else if (n instanceof specialNoDollarRBrace20) endVisit((specialNoDollarRBrace20) n);
+            else if (n instanceof specialNoDollarRBrace21) endVisit((specialNoDollarRBrace21) n);
+            else if (n instanceof specialNoDollarRBrace22) endVisit((specialNoDollarRBrace22) n);
+            else if (n instanceof specialNoDollarRBrace23) endVisit((specialNoDollarRBrace23) n);
+            else if (n instanceof specialNoDollarRBrace24) endVisit((specialNoDollarRBrace24) n);
+            else if (n instanceof specialNoDollarRBrace25) endVisit((specialNoDollarRBrace25) n);
+            else if (n instanceof specialNoDollarRBrace26) endVisit((specialNoDollarRBrace26) n);
+            else if (n instanceof specialNoDollarRBrace27) endVisit((specialNoDollarRBrace27) n);
+            else if (n instanceof specialNoDollarRBrace28) endVisit((specialNoDollarRBrace28) n);
+            else if (n instanceof specialNoDollarRBrace29) endVisit((specialNoDollarRBrace29) n);
+            else if (n instanceof special0) endVisit((special0) n);
+            else if (n instanceof special1) endVisit((special1) n);
+            else if (n instanceof special2) endVisit((special2) n);
+            else if (n instanceof special3) endVisit((special3) n);
+            else if (n instanceof special4) endVisit((special4) n);
+            else if (n instanceof special5) endVisit((special5) n);
+            else if (n instanceof special6) endVisit((special6) n);
+            else if (n instanceof special7) endVisit((special7) n);
+            else if (n instanceof special8) endVisit((special8) n);
+            else if (n instanceof special9) endVisit((special9) n);
+            else if (n instanceof special10) endVisit((special10) n);
+            else if (n instanceof special11) endVisit((special11) n);
+            else if (n instanceof special12) endVisit((special12) n);
+            else if (n instanceof special13) endVisit((special13) n);
+            else if (n instanceof special14) endVisit((special14) n);
+            else if (n instanceof special15) endVisit((special15) n);
+            else if (n instanceof special16) endVisit((special16) n);
+            else if (n instanceof special17) endVisit((special17) n);
+            else if (n instanceof special18) endVisit((special18) n);
+            else if (n instanceof special19) endVisit((special19) n);
+            else if (n instanceof special20) endVisit((special20) n);
+            else if (n instanceof special21) endVisit((special21) n);
+            else if (n instanceof special22) endVisit((special22) n);
+            else if (n instanceof special23) endVisit((special23) n);
+            else if (n instanceof special24) endVisit((special24) n);
+            else if (n instanceof special25) endVisit((special25) n);
+            else if (n instanceof special26) endVisit((special26) n);
+            else if (n instanceof special27) endVisit((special27) n);
+            else if (n instanceof special28) endVisit((special28) n);
+            else if (n instanceof special29) endVisit((special29) n);
+            else if (n instanceof special30) endVisit((special30) n);
+            else if (n instanceof special31) endVisit((special31) n);
+            else if (n instanceof special32) endVisit((special32) n);
+            throw new UnsupportedOperationException("visit(" + n.getClass().toString() + ")");
+        }
+    }
+
+    public void ruleAction(int ruleNumber)
+    {
+        switch (ruleNumber)
+        {
+ 
+            //
+            // Rule 1:  digit ::= 0
+            //
+            case 1:
+                break; 
+            //
+            // Rule 2:  digit ::= 1
+            //
+            case 2:
+                break; 
+            //
+            // Rule 3:  digit ::= 2
+            //
+            case 3:
+                break; 
+            //
+            // Rule 4:  digit ::= 3
+            //
+            case 4:
+                break; 
+            //
+            // Rule 5:  digit ::= 4
+            //
+            case 5:
+                break; 
+            //
+            // Rule 6:  digit ::= 5
+            //
+            case 6:
+                break; 
+            //
+            // Rule 7:  digit ::= 6
+            //
+            case 7:
+                break; 
+            //
+            // Rule 8:  digit ::= 7
+            //
+            case 8:
+                break; 
+            //
+            // Rule 9:  digit ::= 8
+            //
+            case 9:
+                break; 
+            //
+            // Rule 10:  digit ::= 9
+            //
+            case 10:
+                break; 
+            //
+            // Rule 11:  aA ::= a
+            //
+            case 11:
+                break; 
+            //
+            // Rule 12:  aA ::= A
+            //
+            case 12:
+                break; 
+            //
+            // Rule 13:  bB ::= b
+            //
+            case 13:
+                break; 
+            //
+            // Rule 14:  bB ::= B
+            //
+            case 14:
+                break; 
+            //
+            // Rule 15:  cC ::= c
+            //
+            case 15:
+                break; 
+            //
+            // Rule 16:  cC ::= C
+            //
+            case 16:
+                break; 
+            //
+            // Rule 17:  dD ::= d
+            //
+            case 17:
+                break; 
+            //
+            // Rule 18:  dD ::= D
+            //
+            case 18:
+                break; 
+            //
+            // Rule 19:  eE ::= e
+            //
+            case 19:
+                break; 
+            //
+            // Rule 20:  eE ::= E
+            //
+            case 20:
+                break; 
+            //
+            // Rule 21:  fF ::= f
+            //
+            case 21:
+                break; 
+            //
+            // Rule 22:  fF ::= F
+            //
+            case 22:
+                break; 
+            //
+            // Rule 23:  gG ::= g
+            //
+            case 23:
+                break; 
+            //
+            // Rule 24:  gG ::= G
+            //
+            case 24:
+                break; 
+            //
+            // Rule 25:  hH ::= h
+            //
+            case 25:
+                break; 
+            //
+            // Rule 26:  hH ::= H
+            //
+            case 26:
+                break; 
+            //
+            // Rule 27:  iI ::= i
+            //
+            case 27:
+                break; 
+            //
+            // Rule 28:  iI ::= I
+            //
+            case 28:
+                break; 
+            //
+            // Rule 29:  jJ ::= j
+            //
+            case 29:
+                break; 
+            //
+            // Rule 30:  jJ ::= J
+            //
+            case 30:
+                break; 
+            //
+            // Rule 31:  kK ::= k
+            //
+            case 31:
+                break; 
+            //
+            // Rule 32:  kK ::= K
+            //
+            case 32:
+                break; 
+            //
+            // Rule 33:  lL ::= l
+            //
+            case 33:
+                break; 
+            //
+            // Rule 34:  lL ::= L
+            //
+            case 34:
+                break; 
+            //
+            // Rule 35:  mM ::= m
+            //
+            case 35:
+                break; 
+            //
+            // Rule 36:  mM ::= M
+            //
+            case 36:
+                break; 
+            //
+            // Rule 37:  nN ::= n
+            //
+            case 37:
+                break; 
+            //
+            // Rule 38:  nN ::= N
+            //
+            case 38:
+                break; 
+            //
+            // Rule 39:  oO ::= o
+            //
+            case 39:
+                break; 
+            //
+            // Rule 40:  oO ::= O
+            //
+            case 40:
+                break; 
+            //
+            // Rule 41:  pP ::= p
+            //
+            case 41:
+                break; 
+            //
+            // Rule 42:  pP ::= P
+            //
+            case 42:
+                break; 
+            //
+            // Rule 43:  qQ ::= q
+            //
+            case 43:
+                break; 
+            //
+            // Rule 44:  qQ ::= Q
+            //
+            case 44:
+                break; 
+            //
+            // Rule 45:  rR ::= r
+            //
+            case 45:
+                break; 
+            //
+            // Rule 46:  rR ::= R
+            //
+            case 46:
+                break; 
+            //
+            // Rule 47:  sS ::= s
+            //
+            case 47:
+                break; 
+            //
+            // Rule 48:  sS ::= S
+            //
+            case 48:
+                break; 
+            //
+            // Rule 49:  tT ::= t
+            //
+            case 49:
+                break; 
+            //
+            // Rule 50:  tT ::= T
+            //
+            case 50:
+                break; 
+            //
+            // Rule 51:  uU ::= u
+            //
+            case 51:
+                break; 
+            //
+            // Rule 52:  uU ::= U
+            //
+            case 52:
+                break; 
+            //
+            // Rule 53:  vV ::= v
+            //
+            case 53:
+                break; 
+            //
+            // Rule 54:  vV ::= V
+            //
+            case 54:
+                break; 
+            //
+            // Rule 55:  wW ::= w
+            //
+            case 55:
+                break; 
+            //
+            // Rule 56:  wW ::= W
+            //
+            case 56:
+                break; 
+            //
+            // Rule 57:  xX ::= x
+            //
+            case 57:
+                break; 
+            //
+            // Rule 58:  xX ::= X
+            //
+            case 58:
+                break; 
+            //
+            // Rule 59:  yY ::= y
+            //
+            case 59:
+                break; 
+            //
+            // Rule 60:  yY ::= Y
+            //
+            case 60:
+                break; 
+            //
+            // Rule 61:  zZ ::= z
+            //
+            case 61:
+                break; 
+            //
+            // Rule 62:  zZ ::= Z
+            //
+            case 62:
+                break; 
+            //
+            // Rule 63:  letter ::= aA
+            //
+            case 63:
+                break; 
+            //
+            // Rule 64:  letter ::= bB
+            //
+            case 64:
+                break; 
+            //
+            // Rule 65:  letter ::= cC
+            //
+            case 65:
+                break; 
+            //
+            // Rule 66:  letter ::= dD
+            //
+            case 66:
+                break; 
+            //
+            // Rule 67:  letter ::= eE
+            //
+            case 67:
+                break; 
+            //
+            // Rule 68:  letter ::= fF
+            //
+            case 68:
+                break; 
+            //
+            // Rule 69:  letter ::= gG
+            //
+            case 69:
+                break; 
+            //
+            // Rule 70:  letter ::= hH
+            //
+            case 70:
+                break; 
+            //
+            // Rule 71:  letter ::= iI
+            //
+            case 71:
+                break; 
+            //
+            // Rule 72:  letter ::= jJ
+            //
+            case 72:
+                break; 
+            //
+            // Rule 73:  letter ::= kK
+            //
+            case 73:
+                break; 
+            //
+            // Rule 74:  letter ::= lL
+            //
+            case 74:
+                break; 
+            //
+            // Rule 75:  letter ::= mM
+            //
+            case 75:
+                break; 
+            //
+            // Rule 76:  letter ::= nN
+            //
+            case 76:
+                break; 
+            //
+            // Rule 77:  letter ::= oO
+            //
+            case 77:
+                break; 
+            //
+            // Rule 78:  letter ::= pP
+            //
+            case 78:
+                break; 
+            //
+            // Rule 79:  letter ::= qQ
+            //
+            case 79:
+                break; 
+            //
+            // Rule 80:  letter ::= rR
+            //
+            case 80:
+                break; 
+            //
+            // Rule 81:  letter ::= sS
+            //
+            case 81:
+                break; 
+            //
+            // Rule 82:  letter ::= tT
+            //
+            case 82:
+                break; 
+            //
+            // Rule 83:  letter ::= uU
+            //
+            case 83:
+                break; 
+            //
+            // Rule 84:  letter ::= vV
+            //
+            case 84:
+                break; 
+            //
+            // Rule 85:  letter ::= wW
+            //
+            case 85:
+                break; 
+            //
+            // Rule 86:  letter ::= xX
+            //
+            case 86:
+                break; 
+            //
+            // Rule 87:  letter ::= yY
+            //
+            case 87:
+                break; 
+            //
+            // Rule 88:  letter ::= zZ
+            //
+            case 88:
+                break; 
+            //
+            // Rule 89:  value ::= simpleStringPrefixed
+            //
+            case 89:
+                break; 
+            //
+            // Rule 90:  value ::= substPrefixed
+            //
+            case 90:
+                break; 
+            //
+            // Rule 91:  simpleStringPrefixed ::= valStringNoSubst
+            //
+            case 91: {
+                setResult(
+                    new simpleStringPrefixed(getLeftIToken(), getRightIToken(),
+                                             (IvalStringNoSubst)getRhsSym(1),
+                                             (IsubstPrefixed)null)
+                );
+          break;
+            } 
+            //
+            // Rule 92:  simpleStringPrefixed ::= valStringNoSubst substPrefixed
+            //
+            case 92: {
+                setResult(
+                    new simpleStringPrefixed(getLeftIToken(), getRightIToken(),
+                                             (IvalStringNoSubst)getRhsSym(1),
+                                             (IsubstPrefixed)getRhsSym(2))
+                );
+          break;
+            } 
+            //
+            // Rule 93:  valStringNoSubst ::= valueStringNoSubst$
+            //
+            case 93: {
+                setResult(
+                    new valStringNoSubst(getLeftIToken(), getRightIToken())
+                );
+          break;
+            } 
+            //
+            // Rule 94:  substPrefixed ::= substitutionList
+            //
+            case 94:
+                break; 
+            //
+            // Rule 95:  substPrefixed ::= substitutionList simpleStringPrefixed
+            //
+            case 95: {
+                setResult(
+                    new substPrefixed(getLeftIToken(), getRightIToken(),
+                                      (substitutionList)getRhsSym(1),
+                                      (IsimpleStringPrefixed)getRhsSym(2))
+                );
+          break;
+            } 
+            //
+            // Rule 96:  substitutionList ::= substitution
+            //
+            case 96: {
+                setResult(
+                    new substitutionList((substitution)getRhsSym(1), true /* left recursive */)
+                );
+          break;
+            } 
+            //
+            // Rule 97:  substitutionList ::= substitutionList substitution
+            //
+            case 97: {
+                ((substitutionList)getRhsSym(1)).add((substitution)getRhsSym(2));
+          break;
+            } 
+            //
+            // Rule 98:  valueStringNoSubst ::= nonSubstStart
+            //
+            case 98:
+                break; 
+            //
+            // Rule 99:  valueStringNoSubst ::= escapedChar
+            //
+            case 99:
+                break; 
+            //
+            // Rule 100:  valueStringNoSubst ::= valueStringNoSubst escapedChar
+            //
+            case 100:
+                break; 
+            //
+            // Rule 101:  valueStringNoSubst ::= valueStringNoSubst letter
+            //
+            case 101:
+                break; 
+            //
+            // Rule 102:  valueStringNoSubst ::= valueStringNoSubst digit
+            //
+            case 102:
+                break; 
+            //
+            // Rule 103:  valueStringNoSubst ::= valueStringNoSubst specialNoDollarRBrace
+            //
+            case 103:
+                break; 
+            //
+            // Rule 104:  substitution ::= $$ {$ ident optParameter }$
+            //
+            case 104: {
+                setResult(
+                    new substitution(getLeftIToken(), getRightIToken(),
+                                     (ident)getRhsSym(3),
+                                     (optParameter)getRhsSym(4))
+                );
+          break;
+            } 
+            //
+            // Rule 105:  optParameter ::= $Empty
+            //
+            case 105: {
+                setResult(null);
+          break;
+            } 
+            //
+            // Rule 106:  optParameter ::= :$ value
+            //
+            case 106: {
+                setResult(
+                    new optParameter(getLeftIToken(), getRightIToken(),
+                                     (Ivalue)getRhsSym(2))
+                );
+          break;
+            } 
+            //
+            // Rule 107:  ident ::= identChars$
+            //
+            case 107: {
+                setResult(
+                    new ident(getLeftIToken(), getRightIToken())
+                );
+          break;
+            } 
+            //
+            // Rule 108:  identChars ::= letter
+            //
+            case 108:
+                break; 
+            //
+            // Rule 109:  identChars ::= identChars letter
+            //
+            case 109:
+                break; 
+            //
+            // Rule 110:  identChars ::= identChars digit
+            //
+            case 110:
+                break; 
+            //
+            // Rule 111:  nonSubstStart ::= letter
+            //
+            case 111:
+                break; 
+            //
+            // Rule 112:  nonSubstStart ::= digit
+            //
+            case 112:
+                break; 
+            //
+            // Rule 113:  nonSubstStart ::= specialNoDollarRBrace
+            //
+            case 113:
+                break; 
+            //
+            // Rule 114:  escapedChar ::= \$ escapableChar
+            //
+            case 114: {
+                setResult(
+                    new escapedChar(getLeftIToken(), getRightIToken(),
+                                    (IescapableChar)getRhsSym(2))
+                );
+          break;
+            } 
+            //
+            // Rule 115:  escapableChar ::= letter
+            //
+            case 115:
+                break; 
+            //
+            // Rule 116:  escapableChar ::= digit
+            //
+            case 116:
+                break; 
+            //
+            // Rule 117:  escapableChar ::= special
+            //
+            case 117:
+                break; 
+            //
+            // Rule 118:  specialNoDollarRBrace ::= +
+            //
+            case 118: {
+                setResult(
+                    new specialNoDollarRBrace0(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 119:  specialNoDollarRBrace ::= -
+            //
+            case 119: {
+                setResult(
+                    new specialNoDollarRBrace1(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 120:  specialNoDollarRBrace ::= (
+            //
+            case 120: {
+                setResult(
+                    new specialNoDollarRBrace2(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 121:  specialNoDollarRBrace ::= )
+            //
+            case 121: {
+                setResult(
+                    new specialNoDollarRBrace3(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 122:  specialNoDollarRBrace ::= "
+            //
+            case 122: {
+                setResult(
+                    new specialNoDollarRBrace4(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 123:  specialNoDollarRBrace ::= !
+            //
+            case 123: {
+                setResult(
+                    new specialNoDollarRBrace5(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 124:  specialNoDollarRBrace ::= @
+            //
+            case 124: {
+                setResult(
+                    new specialNoDollarRBrace6(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 125:  specialNoDollarRBrace ::= `
+            //
+            case 125: {
+                setResult(
+                    new specialNoDollarRBrace7(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 126:  specialNoDollarRBrace ::= ~
+            //
+            case 126: {
+                setResult(
+                    new specialNoDollarRBrace8(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 127:  specialNoDollarRBrace ::= .
+            //
+            case 127: {
+                setResult(
+                    new specialNoDollarRBrace9(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 128:  specialNoDollarRBrace ::= /
+            //
+            case 128: {
+                setResult(
+                    new specialNoDollarRBrace10(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 129:  specialNoDollarRBrace ::= %
+            //
+            case 129: {
+                setResult(
+                    new specialNoDollarRBrace11(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 130:  specialNoDollarRBrace ::= &
+            //
+            case 130: {
+                setResult(
+                    new specialNoDollarRBrace12(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 131:  specialNoDollarRBrace ::= ^
+            //
+            case 131: {
+                setResult(
+                    new specialNoDollarRBrace13(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 132:  specialNoDollarRBrace ::= :
+            //
+            case 132: {
+                setResult(
+                    new specialNoDollarRBrace14(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 133:  specialNoDollarRBrace ::= ;
+            //
+            case 133: {
+                setResult(
+                    new specialNoDollarRBrace15(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 134:  specialNoDollarRBrace ::= '
+            //
+            case 134: {
+                setResult(
+                    new specialNoDollarRBrace16(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 135:  specialNoDollarRBrace ::= |
+            //
+            case 135: {
+                setResult(
+                    new specialNoDollarRBrace17(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 136:  specialNoDollarRBrace ::= {
+            //
+            case 136: {
+                setResult(
+                    new specialNoDollarRBrace18(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 137:  specialNoDollarRBrace ::=  
+            //
+            case 137: {
+                setResult(
+                    new specialNoDollarRBrace19(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 138:  specialNoDollarRBrace ::= [
+            //
+            case 138: {
+                setResult(
+                    new specialNoDollarRBrace20(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 139:  specialNoDollarRBrace ::= ]
+            //
+            case 139: {
+                setResult(
+                    new specialNoDollarRBrace21(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 140:  specialNoDollarRBrace ::= ?
+            //
+            case 140: {
+                setResult(
+                    new specialNoDollarRBrace22(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 141:  specialNoDollarRBrace ::= ,
+            //
+            case 141: {
+                setResult(
+                    new specialNoDollarRBrace23(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 142:  specialNoDollarRBrace ::= <
+            //
+            case 142: {
+                setResult(
+                    new specialNoDollarRBrace24(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 143:  specialNoDollarRBrace ::= >
+            //
+            case 143: {
+                setResult(
+                    new specialNoDollarRBrace25(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 144:  specialNoDollarRBrace ::= =
+            //
+            case 144: {
+                setResult(
+                    new specialNoDollarRBrace26(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 145:  specialNoDollarRBrace ::= #
+            //
+            case 145: {
+                setResult(
+                    new specialNoDollarRBrace27(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 146:  specialNoDollarRBrace ::= *
+            //
+            case 146: {
+                setResult(
+                    new specialNoDollarRBrace28(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 147:  specialNoDollarRBrace ::= _
+            //
+            case 147: {
+                setResult(
+                    new specialNoDollarRBrace29(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 148:  special ::= +
+            //
+            case 148: {
+                setResult(
+                    new special0(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 149:  special ::= -
+            //
+            case 149: {
+                setResult(
+                    new special1(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 150:  special ::= (
+            //
+            case 150: {
+                setResult(
+                    new special2(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 151:  special ::= )
+            //
+            case 151: {
+                setResult(
+                    new special3(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 152:  special ::= "
+            //
+            case 152: {
+                setResult(
+                    new special4(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 153:  special ::= !
+            //
+            case 153: {
+                setResult(
+                    new special5(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 154:  special ::= @
+            //
+            case 154: {
+                setResult(
+                    new special6(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 155:  special ::= `
+            //
+            case 155: {
+                setResult(
+                    new special7(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 156:  special ::= ~
+            //
+            case 156: {
+                setResult(
+                    new special8(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 157:  special ::= .
+            //
+            case 157: {
+                setResult(
+                    new special9(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 158:  special ::= /
+            //
+            case 158: {
+                setResult(
+                    new special10(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 159:  special ::= %
+            //
+            case 159: {
+                setResult(
+                    new special11(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 160:  special ::= &
+            //
+            case 160: {
+                setResult(
+                    new special12(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 161:  special ::= ^
+            //
+            case 161: {
+                setResult(
+                    new special13(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 162:  special ::= :
+            //
+            case 162: {
+                setResult(
+                    new special14(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 163:  special ::= ;
+            //
+            case 163: {
+                setResult(
+                    new special15(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 164:  special ::= '
+            //
+            case 164: {
+                setResult(
+                    new special16(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 165:  special ::= \
+            //
+            case 165: {
+                setResult(
+                    new special17(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 166:  special ::= |
+            //
+            case 166: {
+                setResult(
+                    new special18(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 167:  special ::= {
+            //
+            case 167: {
+                setResult(
+                    new special19(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 168:  special ::=  
+            //
+            case 168: {
+                setResult(
+                    new special20(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 169:  special ::= }
+            //
+            case 169: {
+                setResult(
+                    new special21(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 170:  special ::= [
+            //
+            case 170: {
+                setResult(
+                    new special22(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 171:  special ::= ]
+            //
+            case 171: {
+                setResult(
+                    new special23(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 172:  special ::= ?
+            //
+            case 172: {
+                setResult(
+                    new special24(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 173:  special ::= ,
+            //
+            case 173: {
+                setResult(
+                    new special25(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 174:  special ::= <
+            //
+            case 174: {
+                setResult(
+                    new special26(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 175:  special ::= >
+            //
+            case 175: {
+                setResult(
+                    new special27(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 176:  special ::= =
+            //
+            case 176: {
+                setResult(
+                    new special28(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 177:  special ::= #
+            //
+            case 177: {
+                setResult(
+                    new special29(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 178:  special ::= *
+            //
+            case 178: {
+                setResult(
+                    new special30(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 179:  special ::= _
+            //
+            case 179: {
+                setResult(
+                    new special31(getRhsIToken(1))
+                );
+          break;
+            } 
+            //
+            // Rule 180:  special ::= $
+            //
+            case 180: {
+                setResult(
+                    new special32(getRhsIToken(1))
+                );
+          break;
+            }
+    
+            default:
+                break;
+        }
+        return;
+    }
+}
+
Index: .settings/org.eclipse.jdt.core.prefs
===================================================================
--- .settings/org.eclipse.jdt.core.prefs	(revision 20755)
+++ .settings/org.eclipse.jdt.core.prefs	(working copy)
@@ -1,4 +1,4 @@
-#Wed Oct 18 15:08:27 EDT 2006
+#Thu Aug 21 16:48:50 BST 2008
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
@@ -7,6 +7,65 @@
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=ignore
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=ignore
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=enabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=ignore
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=ignore
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=ignore
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=ignore
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=ignore
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=ignore
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
 org.eclipse.jdt.core.compiler.source=1.5
