-----------------------------------------------------------------------
-- EMOF
-----------------------------------------------------------------------
package EMOF

context Class
def: allOwnedAttributes : Set(Property)
    = superClass.allOwnedAttributes->asSet()->union(ownedAttribute)
def: allSuperClasses : Set(Class)
    = superClass.allSuperClasses->asSet()->union(superClass)
def: definesProperty(p : Property) : Boolean
    = allOwnedAttributes->includes(p)
    
context Element
def: ancestors : OrderedSet(Element)
    = if container() <> null
    then container().oclAsType(Element).ancestors->append(self)
    else self->asOrderedSet() endif   
def: children : Set(Element)
    = Element.allInstances()->select(e | e.ancestors->includes(self))   
def: allVariableExps : Set(EssentialOCL::VariableExp)
    = children->select(oclIsKindOf(EssentialOCL::VariableExp)).oclAsType(EssentialOCL::VariableExp)->asSet()
def: allReferencedVariables : Set(EssentialOCL::Variable)
    = allVariableExps.referredVariable->asSet()
def: allOclExpressions : Set(EssentialOCL::OclExpression)
    = children->select(oclIsKindOf(EssentialOCL::OclExpression)).oclAsType(EssentialOCL::OclExpression)->asSet()
def: allCollectionTypes : Set(EssentialOCL::CollectionType)
    = allOclExpressions.type->select(oclIsKindOf(EssentialOCL::CollectionType)).oclAsType(EssentialOCL::CollectionType)->asSet()
--def: properAncestors : OrderedSet(Element)
----    = ancestors->excluding(self)
--    = ancestors->excluding(self)->asOrderedSet()   
--def: properChildren : Set(Element)
--    = children->excluding(self)
    
context Type
def: elementType() : Type
    = if oclIsKindOf(EssentialOCL::CollectionType)
    then oclAsType(EssentialOCL::CollectionType).elementType
    else self endif
def: assignableFrom(t : Type) : Boolean
    = t.getMetaClass().allSuperClasses->includes(getMetaClass())   
def: matches(t : Type) : Boolean
    = self = t                   -- FIXME   

endpackage

-----------------------------------------------------------------------
-- EssentialOCL
-----------------------------------------------------------------------
package EssentialOCL

context OclExpression
def: allReferencedTypes : Set(EMOF::Type)
    = allOclExpressions.type->asSet()
def: allReferencedCollectionTypes : Set(CollectionType)
    = allOclExpressions.type->select(oclIsKindOf(CollectionType)).oclAsType(CollectionType)->asSet()
def: allReferencedElementTypes : Set(EMOF::Type)
    = allOclExpressions.type.elementType()->asSet()
def: nonExpressionParent : EMOF::Element
    = if container().oclIsKindOf(OclExpression)
    then container().oclAsType(OclExpression).nonExpressionParent
    else container()
    endif
    
context VariableExp
inv UnderscoreOnlyUsedAsCollectionTemplateExpRest:
    name = '_' implies nonExpressionParent.oclIsKindOf(QVTTemplate::CollectionTemplateExp)
    
context CollectionType
def: kind() : CollectionKind
    = if oclIsKindOf(BagType) then CollectionKind::Bag
    else if oclIsKindOf(OrderedSetType) then CollectionKind::OrderedSet
    else if oclIsKindOf(SequenceType) then CollectionKind::Sequence
    else if oclIsKindOf(SetType) then CollectionKind::Set
    else CollectionKind::Collection endif endif endif endif

endpackage

-----------------------------------------------------------------------
-- QVTBase
-----------------------------------------------------------------------
package QVTBase

context TypedModel
def: allDependsOn : Set(TypedModel)
    = if (dependsOn <> null)
    then dependsOn.allDependsOn->union(dependsOn)->asSet()
    else Set{} endif
def: declaredPackages : Set(EMOF::Package)
    = dependsOn.declaredPackages->asSet()->union(usedPackage)
def: declaresType(t : EMOF::Type) : Boolean
    = declaredPackages->includes(t._package)
--inv TypedModelDefinedByTransformation :
--    transformation.definesModel(self)
inv DependsOnIsAcyclic :
    allDependsOn->excludes(self)

context Transformation
def: allExtends : Set(Transformation)
    = if (extends <> null)
    then extends.allExtends->including(extends)
    else Set{} endif
def: declaredPackages : Set(EMOF::Package)
    = modelParameter.declaredPackages->asSet()
def: declaresRule(r : Rule) : Boolean
    = rule->includes(r) or extends->exists(declaresRule(r)) 
def: declaresType(t : EMOF::Type) : Boolean
    = declaredPackages->includes(t._package)
def: definesModel(m : TypedModel) : Boolean
    = modelParameter->includes(m)
inv ExtendsIsAcyclic :
    allExtends->excludes(self)
inv ExtendsIsCompatible :
    extends <> null implies declaredPackages = extends.declaredPackages
inv KeysAreDistinctWarning :
    true -- FIXME
inv ModelParameterNamesAreUnique :
    modelParameter->isUnique(name)
inv RuleNamesAreUnique :
    rule->isUnique(name)
inv SynthesizedTypesAreOwned :
    ownedType->includesAll(allCollectionTypes)

context Domain
def: transformation : Transformation
    = rule.transformation
inv TypedModelDefinedByTransformation :
    typedModel <> null implies transformation.definesModel(typedModel)
inv NotBothCheckableAndEnforceable :
    not (isCheckable and isEnforceable)

context Rule
inv OverridesIsCompatible :
    overrides <> null implies true -- FIXME
inv OverridesDefinedByTransformation :
    overrides <> null implies transformation.declaresRule(overrides)

context Function
inv IsSideEffectFree :
    true -- FIXME no RelationCallExp, no ImperativeOCL
inv EveryFunctionParameterIsAFunctionParameter :
    ownedParameter->forAll(oclIsKindOf(FunctionParameter))

context Predicate
inv ConditionExpressionIsBoolean :
    conditionExpression.type.oclIsKindOf(Boolean)
inv VariablesAreBoundByPattern :
    pattern.bindsTo->includesAll(allReferencedVariables)

context Pattern
inv VariablesAreNotParameters :
    not bindsTo->exists(oclIsKindOf(FunctionParameter))
        
endpackage

-----------------------------------------------------------------------
-- QVTRelation
-----------------------------------------------------------------------
package QVTRelation

context RelationalTransformation
def: relations : Set(Relation)
    = rule.oclAsType(Relation)->asSet()
inv EveryRuleIsARelation :
    rule->forAll(oclIsKindOf(Relation))
--inv HasTopLevelRelation :
--    relations->exists(isTopLevel)

context Relation
def: domains : OrderedSet(RelationDomain)
    = domain.oclAsType(RelationDomain)->asOrderedSet()
def: declaredPackages : Set(EMOF::Package)
    = domain.typedModel.usedPackage->asSet()
def: declaresType(t : EMOF::Type) : Boolean
    = declaredPackages->includes(t._package)
def: definesVariable(v : EssentialOCL::Variable) : Boolean
    = variable->includes(v)
def: relationalTransformation : RelationalTransformation
    = transformation.oclAsType(RelationalTransformation)
def: whenExpressions : Bag(EssentialOCL::OclExpression)
    = if when = null then Bag{} else when.predicate.conditionExpression endif
def: whereExpressions : Bag(EssentialOCL::OclExpression)
    = if where = null then Bag{} else where.predicate.conditionExpression endif
inv EveryDomainIsARelationDomain :
    domain->forAll(oclIsKindOf(RelationDomain))
inv HasAtLeastTwoDomains :
    domains->size() >= 2
inv NonTopLevelIsNotInvokedWarning :
    not isTopLevel implies not RelationCallExp.allInstances()->exists(referredRelation =self)
inv RelationImplsAreUniqueWarning :
    operationalImpl->isUnique(impl)
inv WhenTypesAreDeclaredByRelation :
    whenExpressions.allReferencedElementTypes->asSet()->forAll(t | declaresType(t))
inv WhenVariablesAreDefinedByRelation :
    whenExpressions.allReferencedVariables->asSet()->forAll(v | definesVariable(v))
inv WhereTypesAreDeclaredByRelation :
    whereExpressions.allReferencedElementTypes->asSet()->forAll(t | declaresType(t))
inv WhereVariablesAreDefinedByRelation :
    whereExpressions.allReferencedVariables->asSet()->forAll(v | definesVariable(v))
-- FIXME Section 7.5 predicate ordering constraints

context RelationDomain
def: relation : QVTRelation::Relation
    = rule.oclAsType(Relation)
def: rootTemplateExpression : QVTTemplate::TemplateExp
    = if pattern <> null
    then pattern.templateExpression
    else null endif
def: declaredPackages : Set(EMOF::Package)
    = typedModel.usedPackage
def: declaresType(t : EMOF::Type) : Boolean
    = declaredPackages->includes(t._package)
inv RootVariableIsDefinedByRelation:
    relation.definesVariable(rootVariable)
inv RootVariableTypeIsDeclaredByDomainTypedModel :
    typedModel.declaresType(rootVariable.type)
--inv RootTemplateExpressionIsBoundToRootVariable :
--    rootTemplateExpression.bindsTo = rootVariable
inv EveryEnforceableVariableIsMatchedOrAssigned :
    isEnforceable implies true -- FIXME

context DomainPattern
def: relationDomain : RelationDomain
--    = domain.oclAsType(RelationDomain)
    = container().oclAsType(RelationDomain)
def: relation : Relation
    = relationDomain.relation
inv EveryVariableIsDefinedByRelation :
      bindsTo->forAll(v | relation.definesVariable(v))
inv RootTemplateExpressionIsBoundToRootVariable :
    templateExpression <> null implies templateExpression.bindsTo = relationDomain.rootVariable
inv RootTemplateExpressionTypeIsRootVariableType :
    templateExpression <> null implies templateExpression.type = relationDomain.rootVariable.type

context Key
inv IdentifiesTypeIsDeclaredByTransformation:
    transformation.declaresType(identifies)
inv EveryPartIsDeclaredByIdentifies:
    part->forAll(p | identifies.definesProperty(p))
inv UsedInSomeTemplateVariableWarning :
    true -- FIXME
inv UsedInTwoOrMoreTemplateVariableWarning :
    true -- FIXME
  
context RelationImplementation
inv RootNodeIsBoundToRootVariable :
    inDirectionOf.declaresType(impl.ownedParameter->first().type.elementType())
inv InDirectionOfIsDefinedByTransformation :
    relation.transformation.definesModel(inDirectionOf)
inv EveryArgumentTypeMatchesDomainRootVariableType :
    let parameters : OrderedSet(EMOF::Parameter) = impl.ownedParameter
    in parameters->forAll(p | p.type.matches(relation.domains->at(parameters->indexOf(p)).rootVariable.type))
-- ?? inputs argument assignable from root variable
-- ?? output root variable assignable from argument
-- FIXME Section 7.8 context constraints

context RelationDomainAssignment
def: relationDomain : RelationDomain
--    = owner
    = container().oclAsType(RelationDomain)
def: relation : Relation
    = relationDomain.relation
inv VariableDefinedByRelation:
    relation.definesVariable(variable)
inv VariableTypeMatchesValueType:
    variable.type.assignableFrom(valueExp.type)

context RelationCallExp
def: pattern : QVTBase::Pattern
    = let parent : EMOF::Element = nonExpressionParent
    in if parent.oclIsKindOf(QVTBase::Pattern)
    then parent.oclAsType(QVTBase::Pattern)
    else null endif
def: relation : Relation
    = let parent : EMOF::Element = nonExpressionParent.container()
    in if parent.oclIsKindOf(Relation)
    then parent.oclAsType(Relation)
    else null endif
def: transformation : RelationalTransformation
    = relation.relationalTransformation
inv PatternExists:
    pattern <> null
inv RelationExists:
    relation <> null
inv InvokedFromWhenOrWhereClause:
    pattern = relation.when or pattern = relation.where
inv ReferredRelationDeclaredByTransformation:
    transformation.declaresRule(referredRelation)
inv ReferredRelationArgumentNumberMatches:
    argument->size() = referredRelation.domain->size()
inv EveryReferredRelationArgumentTypeMatches:
    argument->forAll(a | a.type.matches(referredRelation.domains->at(argument->indexOf(a))->rootVariable.type))

endpackage

-----------------------------------------------------------------------
-- QVTTemplate
-----------------------------------------------------------------------
package QVTTemplate

context TemplateExp
def: domainPattern : QVTRelation::DomainPattern
    = if container().oclIsKindOf(QVTRelation::DomainPattern)
    then container().oclAsType(QVTRelation::DomainPattern)
    else container().oclAsType(QVTTemplate::PropertyTemplateItem).objContainer.domainPattern endif
def: relation : QVTRelation::Relation
    = domainPattern.relation
def: relationDomain : QVTRelation::RelationDomain
    = domainPattern.relationDomain
inv VariableIsDefinedByRelation:
    bindsTo <> null implies relation.definesVariable(bindsTo)
inv VariableTypeIsDeclaredByDomain:
    bindsTo <> null implies relationDomain.declaresType(bindsTo.type.elementType())
inv WhereIsBoolean:
    where <> null implies where.type.oclIsKindOf(Boolean)

context ObjectTemplateExp
inv ReferredClassIsDeclaredByDomain:
    relationDomain.declaresType(referredClass)

context CollectionTemplateExp
def: elementType : EMOF::Type
    = referredCollectionType.elementType
inv ReferredCollectionTypeIsDeclaredByDomain:
    relationDomain.declaresType(elementType)
inv EveryMemberTypeMatchesElementType:
    member->forAll(m | m.type.matches(elementType))
inv RestTypeMatchesElementType:
    rest.type.matches(elementType)

context PropertyTemplateItem
def: domainPattern : QVTRelation::DomainPattern
    = objContainer.domainPattern
def: relation : QVTRelation::Relation
    = domainPattern.relation
def: relationDomain : QVTRelation::RelationDomain
    = domainPattern.relationDomain
def: valueCollectionType : EssentialOCL::CollectionType
    = if (value.oclIsKindOf(CollectionTemplateExp))
    then value.oclAsType(CollectionTemplateExp).referredCollectionType
    else null endif
inv ReferredPropertyIsDefinedByReferredClass:
    objContainer.referredClass.definesProperty(referredProperty)
inv ValueIsATemplateExp:
    value.oclIsKindOf(TemplateExp)
inv ValueElementTypeMatchesReferredPropertyElementType :
    referredProperty.type.elementType().assignableFrom(value.type.elementType())
-- FIXME set conversions
inv SetCollectionTemplateExpressionMatchesSet :
    valueCollectionType.oclIsKindOf(EssentialOCL::SetType)
    implies referredProperty.upper > 1 and not referredProperty.isOrdered and referredProperty.isUnique 
inv OrderedCollectionTemplateExpressionMatchesNonBag :
    valueCollectionType.oclIsKindOf(EssentialOCL::OrderedSetType)
    or valueCollectionType.oclIsKindOf(EssentialOCL::SequenceType)
    implies referredProperty.upper > 1 and (referredProperty.isOrdered or referredProperty.isUnique) 
    
endpackage
